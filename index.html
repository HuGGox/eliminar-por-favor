<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="js/index.js"></script>
    <link rel="stylesheet" href="estilos.css">
</head>
<body>
    <p>
        JavaScript:
        Tipos de datos:

        Existen 9 tipos de datos pero por ahora vamos a trabajar solo 3:
        String: Texto encerrado en '' o ""
        Numerico: 20 - 1.2, etc
        Boolean: Falso o Verdadero (True-False)
        Si el dato en consola esta en negro es string, si esta en azul es numerico, por ende si un numero esta en negro significa que esta pasado como string.
        Si ponemos los numeros decimales con . va a leerse como decimal, si lo ponemos con , va a leerse como si fuesen 2 parametros, ej: 20.6, si ponemos 20,6 va a leerse 20 y 6.

        Las variables funcionan igual que en pseint, es un dato guardado dentro de una caja.
        Hay 3 tipos de variables:
        var
        let
        const

        Cuando declaramos una variable lo hacemos de la siguiente manera

        let nombreUsuario = "roberto"
        Lo que ponemos despues del = (signo de asignacion) es lo que va a viajar dentro de la cajita(nombreUsuario en este caso)

        Para concatenar en JS nosotros ponemos el signo +, por ej:
        console.log("mi nombre es:" + "Roberto");

        Para poder guardar los datos del prompt utilizamos una variable:
        let numeroUno = prompt("escribe un numero");
        console.log(numeroUno)

        Para ver que tipo de dato es usamos el typeof:

        console.log(typeof nombreVariable)

        Con parseInt() transformamos un string(cadena de texto) en un numero entero. Por ej:

        console.log(parseInt(numeroUno));

        let resultado = parseInt(numeroUno) + parseInt(numeroDos);


        
        Operadores:

        Operadores Aritmeticos o Algebraicos:

        let resultado = (2 * (100 / 5) + 10);
        console.log (resultado);

        Operadores Relacionales:

        <, >, >=, <=, ===, !==.

        Estrictamente vamos a utilizar los === y !== para diferenciar de una manera mas rigida los completamente iguales de los completamente diferentes.

        Operadores Logicos: 

        Los op. logicos se utilizan para combinar dos valores booleanos y devolver un resultado verdadero, falso o nulo. Los operadores logicos tambien son conocidos como operadores booleanos.

        &&: Si los dos son verdaderos devuelve verdadero.
        ‚îÇ‚îÇ: Con que uno sea verdadero devolvera verdadero. 
        !: Negacion.




        Estructuras de control: 

        En lenguajes de programacion, las estructuras de control permiten modificar el flujo de ejecucion de las instrucciones de un programa.

        Condicionales:

        if/else: si ocurre algo haz esto, sino, haz esto otro.
        ?: operador ternario: Equivalente a if/else, modo abreviado. Utiliza la condicion:
        Si la condicion se cumple "() ? true : false" utilizamos el signo de interrogacion y devolvemos el true, si no se cumple, utilizamos los dos puntos y devolvemos false.
        switch: Estructura para casos especificos: Similar a varios if/else anidados.

        Repetitivas o iterativas:

        while
        do...while 
        for 



        if/else:

        if (aca va la condicion) {
            aca va el bloque verdadero
        }else {
            aca va el bloque falso
        }



        TemplateString : `` Nos permiten hacer toda una cadena de texto de varios renglones y los mismos son tomados con espacios, por ej:

        let opcionUsuario = prompt (`
        Elija una opcion:
        1. Libros
        2. Peliculas
        3. Juegos
        `);
        console.log(opcionUsuario); 



        Array:

        Los arrays son objetos similares a una lista cuyo prototipo proporciona metodos para efectuar operaciones de recorrido y mutacion. Tanto la longitud como el tipo de los elementos de un array son variables.
        Los arrays pueden tener los 3 tipos de datos, string-boolean-numericos sin problemas.
        Length es el tama√±o del array, con console.log(x.length) podemos verlo.


        For: 

        Crea un bucle que consiste en tres expresiones opcionales encerradas en parentesis y separadas por puntos y comas, seguidas de una sentencia ejecutada en un bucle.
        for (let i = 0; i <= 3; i++) {}
        La i es de indice del array (que empieza en 0), el cero va justamente por el comienzo del array, y mientras la i se mantenga en igualdad o menor a 3 (tama√±o completo del array) el for se va a ejecutar dado que le pusimos un elemeneto de incremento (i++)

        Para hacerlo dinamico
        for (let i = 0; i < frutas.length; i++) {}
        Esto no va a tomar el tipo de dato del array, sino que va a recorrerlo por el indice, como agregamos uva al ejemplo de frutas, esto se vuelve dinamico y va a mostrarnos uva en pantalla sin la necesidad de cambiar el 3 por un 4.

        

        For of:

        La sentencia for...of ejecuta un bloque de codigo para cada elemento de un objeto iterable como lo son: String, Array, objetos similares a array(por ej, arguments or NodeList), TypedArray, Map, Set e iterables definidos por el usuario.

        for (let fruta of frutas) {
            console.log(fruta);
        }

        De esta manera es lo mismo que el for dado que recorre los elementos del array (a estos les pusimos fruta dado que es lo que son, fruta seria lo que recorre frutas).

        Como dijimos, tambien se puede recorrer un string:

        let nombreUsuario = "Roberto"

        for (let letra of nombreUsuario) {
            console.log(letra);
        }


        Funciones:

        Las funciones son unos de los bloques de construccion fundamentales en JS. Una funcion en JS es similar a un procedimiento--un conjunto de instrucciones que realiza una tarea o calcula un valor, pero para que un procedimiento califique como funcion, debe tomar alguna entrada y devolver una salida donde hay alguna relacion obvia entre la entrada y la salida.

        Tiene un nombre.
        Una lista de parametros de la funcion, entre parentesis y separados por comas.
        Las declaraciones de JS que definen la funcion, encerradas entre {}



        TENER ESTO SIEMPRE EN LA CABEZA:

        HOISTING:

        Una estricta definicion de hoisting sugiere que las declaraciones de variables y funciones son fisicamentes movidas al comienzo del codigo, pero esto no es lo que ocurre en realidad. Lo que sucede es que las declaraciones de variables y funciones son asignadas en memoria durante la fase de compilacion, pero quedan exactamente en donde las has escrito en codigo.
        EN POCAS PALABRAS: JS hace un barrido, no ejecuta nada, pero en la memoria ram que tiene, lee todo el codigo, despues de eso sabe que las funciones van arriba, una vez que acomodo las funciones lee lo que tiene la funcion y la ejecuta.


        Funciones con argumentos/parametros: 

        function saludar (nombreUsuario) {
            console.log('holis ' + nombreUsuario);
        }
        
        
        saludar("Ricar2");


        Funciones con retorno:

        function saludar (nombreUsuario) {
            return ('holis ' + nombreUsuario);
        }
        
        console.log(saludar("ricar2"))





        Conceptos Claves:

        Tip de un libro:

        Preocuparse por la eficiencia puede ser una distraccion. Es otro factor mas que complica el dise√±o del programa, y cuando estas haciendo algo que ya es dificil, esa cosa extra de la que preocuparte puede ser paralizante. Por lo tanto, comienza siempre por escribir algo que sea correcto y facil de entender. Si te preocupa que sea demasiado lento, que normalmente no lo es, ya que la mayoria del codigo simplemente no se ejecuta con la frecuencia suficiente para llevar una cantidad significativa de tiempo, puedes medirlo despues y mejorarlo si es necesario.



        Para hacer un salto de linea utilizamos \n (es alt 92).

        TemplateString: Para hacer las comillas invertidas (``) utilizamos alt 96.

        Interpolacion TemplateString:

        Las plantillas literales son cadenas literales que habilitan el uso de expresiones incrustadas. Con ellas, es posible utilizar cadenas de caracteres de mas de una linea, y funcionalidades de interpolacion de cadenas de caracteres.

        TemplateString:

        Las plantillas de cadena de caracteres pueden contener marcadores, identificados por el signo de dolar y envueltos en llaves ${expresion}. Las expresiones contenidas en los marcadores, junto con el texto entre ellas, son enviados como argumentos a una funcion. 

        Interpolacion de expresiones:

        La interpolacion hace referencia al ambito global.
        Para poder llamar a una propiedad dentro de un objeto tenemos que hacerlo con el nombre del objeto.

        let nombreUsuario = "ricar2"
        console.log ("\n Bienvenido : \n " + nombreUsuario + "\n");

        Con la interpolacion podemos llamar a una variable. Tambien podemos utilizar metodos en la interpolacion, por ej:

        let nombreUsuario = "Ricar2";

        console.log(`bienvenido
        ${nombreUsuario.toUpperCase()}`);

        Tambien interpreta el operador ternario:

        let nombreUsuario = "Ricar2";
        let estado = true;

        console.log(`bienvenido ${nombreUsuario.toUpperCase()}`);
        console.log(`
        ${estado ? "en linea" : "offline"}
        `);




        var vs let vs const:

        Uno de los mayores problemas al declarar variables con var, es que puede sobrescribir las declaraciones de variables sin errores.
        En una aplicaci√≥n peque√±a, es posible que no se encuentre con este tipo de problema, pero cuando su c√≥digo se agrande, puede sobrescribir accidentalmente una variable que no ten√≠a la intenci√≥n de sobrescribir.

        Debido a que este comportamiento no arroja un error, la b√∫squeda y correcci√≥n de errores se vuelve m√°s dif√≠cil. Se introdujo let una nueva palabra clave llamada en ES6 para resolver este problema potencial con var.      

        let: Una variable con el mismo nombre solo se puede declarar una vez.

        let estado = true;
        let estado = false;
        console.log(estado);
         
        Aqui nos arroja un error dado que nos dice que la variable ya esta declarada previamente.

        Pero si se puede cambiar su valor:

        let estado = true;
        estado = false;
        console.log(estado);

        Aqui nos permite poner 2 veces el mismo nombre dado que al sacar el segundo let estamos diciendole a JS que estamos reescribiendo la variable.


        Scope:

        En simples palabras el "scope de una variable" hace referencia al lugar donde esta va a vivir o podr√° ser accesible.

        Cuando declaras una variable con var, se declara globalmente o localmente si se declara dentro de una funci√≥n.

        var estado = true
        if (estado) {
        var estado = false
        }
        console.log(estado)

        let se comporta de manera similar, pero con algunas caracter√≠sticas adicionales. Cuando declaras una variable con let dentro de un bloque, declaraci√≥n o expresi√≥n, su alcance se limita a ese bloque, declaraci√≥n o expresi√≥n.

        let estado = true
        if (estado) {
            let estado = false
            console.log(estado)
        }
        console.log(estado)



        Const:
       

        
        const tiene todas las caracter√≠sticas incre√≠bles de let, con la ventaja adicional de que las variables declaradas usando const son de solo lectura. Son un valor constante, lo que significa que una vez que se asigna una variable const, no se puede reasignar.
        
        Error:
        estado = false
        const estado = true

        
        Error:
        for (const i = 0; i < 10; i++) {
            console.log(i)
        }

        Valido:

        const estado = true
        if (estado) {
            const estado = false
            console.log(estado)
        }
        console.log(estado)



        TIP:

        Algunos desarrolladores prefieren asignar todas sus variables usando const de forma predeterminada (me incluyo), a menos que sepan que necesitar√°n reasignar el valor. Solo en ese caso, usan let.


        Array vs const:

        Es importante comprender que los objetos (incluidos los arreglos y las funciones) asignados a una variable mediante el uso const siguen siendo mutables. El uso de const solo evita la reasignaci√≥n del identificador de variable.

        Error:

        const miArray = []
        miArray = ["nuevoElemento"]

        V√°lido:

        const miArray = []
        miArray[0] = ["nuevoElemento"]
        console.log(miArray)


        Siempre y cuando modifiquemos desde el indice el array vamos a poder modificar una constante.

        Array (push, pop, shift, unshift):

        El m√©todo push() a√±ade uno o m√°s elementos al final de un array y devuelve la nueva longitud del array.

        const frutas = ["Banana"]
        frutas.push("Sand√≠a")
        console.log(frutas)

        El m√©todo unshift() agrega uno o m√°s elementos al inicio del array, y devuelve la nueva longitud del array.

        const frutas = ["Banana"]
        frutas.unshift("Sand√≠a")
        console.log(frutas)

        El m√©todo pop() elimina el √∫ltimo elemento de un array y lo devuelve. Este m√©todo cambia la longitud del array.

        const frutas = ["manzana", "pera"];

        frutas.unshift("uva");

        const frutaEliminada = frutas.pop();

        console.log(frutas);
        console.log(frutaEliminada);

        El m√©todo shift() elimina el primer elemento del array y lo retorna. Este m√©todo modifica la longitud del array.

        const frutas = ["manzana", "pera"];

        frutas.unshift("uva");
        
        const frutaEliminada = frutas.shift();
        
        console.log(frutas);
        console.log(frutaEliminada);




        
        Funciones an√≥nimas

        En JavaScript, usualmente no necesitas nombrar tus funciones, especialmente cuando se pasa una funci√≥n como argumento a otra funci√≥n. En su lugar, creamos funciones inline (en l√≠nea). No necesitamos nombrar estas funciones porque no las reutilizamos en otro lugar.
        
        Funci√≥n declarativa:
        
        // declaro la funci√≥n
        function numAleatorioRango(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }
        
        // invoco la funci√≥n
        console.log(numAleatorioRango(1, 11))
        
        Funci√≥n expresada:
        An√≥nima (expresada en una variable):
        
        const miNumero = function (min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }
        console.log(miNumero(1, 11))
        
        Diferencia declarativa vs Expresada:
        
        console.log(miNumero(1, 11))
        const miNumero = function (min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }
        
        TIP
        
        La forma correcta de definir una funci√≥n var√≠a seg√∫n el comportamiento que esperemos de la misma: con las funciones declaradas, tenemos la seguridad de que siempre estar√°n disponibles en tiempo de ejecuci√≥n. Con las funciones expresadas, tendremos que √©stas no son evaluadas hasta que el int√©rprete no alcance su posici√≥n en el c√≥digo, lo cual puede generar errores en arquitecturas muy anidadas.
        
        El hecho de que las funciones declarativas se eval√∫en antes que las expresiones, pueden producir comportamientos no deseados cuando forman parte de condicionales. Para estos casos, el uso de las funciones expresadas garantiza que √©stas formar√°n parte del flujo general del programa, lo cual puede evitarnos sorpresa en determinados entornos.


        ES6 nos proporciona el az√∫car sint√°ctico, para no tener que escribir funciones an√≥nimas de este modo. En su lugar, puedes usar la sintaxis de funci√≥n flecha.

    


        Arrow Function:

    
        (opens new window): Una expresi√≥n de funci√≥n flecha es una alternativa compacta a una expresi√≥n de funci√≥n tradicional
    
        const miNumeroFlecha = (max) => {
        return Math.floor(Math.random() * (max - 1)) + 1;
        }
    
        console.log(miNumeroFlecha(11))
    
        Reducci√≥n:
    
        const miNumeroFlecha = max => Math.floor(Math.random() * (max - 1)) + 1;
            
        console.log(miNumeroFlecha(11))
    
        Reducci√≥n con par√©ntesis:
    
        const miNumeroFlecha = max => (Math.floor(Math.random() * (max - 1)) + 1);
            
        console.log(miNumeroFlecha(11))
    
        M√°s par√°metros:
    
        const miNumeroFlecha = (min, max) => Math.floor(Math.random() * (max - min)) + min;
    
        console.log(miNumeroFlecha(1, 11))
    
        Par√°metros opcionales (tambi√©n se puede hacer con function):
    
        const miNumeroFlecha = (min = 1, max = 10) => Math.floor(Math.random() * (max - min)) + min;
    
        console.log(miNumeroFlecha())
    
        Limitantes:
    
        No tiene sus propios enlaces a this o super y no se debe usar como m√©todos.
        No tiene argumentos o palabras clave new.target.
        No apta para los m√©todos call, apply y bind, que generalmente se basan en establecer un √°mbito o alcance
        No se puede utilizar como constructor.



        forEach()

        (opens new window): El m√©todo forEach() ejecuta la funci√≥n indicada una vez por cada elemento del array.
    
        let frutas = ["manzana", "sand√≠a", "pera"]
        frutas.forEach(fruta => console.log(fruta))
    
        let frutas = ["manzana", "sand√≠a", "pera"]
        frutas.forEach((fruta, index, array) => {
        console.log(index)
        console.log(fruta)
        console.log(array)
        })
    
        En nuestro ejemplo de carrito de compras:
    
        const carrito = []
        const fruta = prompt('üçí Feria Market üçâ ¬øqu√© fruta desea comprar?')
    
        carrito.push(fruta)
    
        while (confirm('¬øDesea agregar otro elemento al üõí?')) {
        const fruta = prompt('¬øqu√© fruta desea comprar?')
        carrito.push(fruta)
        }
    
        console.log('Ustede compr√≥: ')
        carrito.forEach((fruta, index) => (
        console.log(`${index + 1}: ${fruta}`)
        ))
    


        Objetos:

        Los objetos siempre se empiezan con {}, pueden tener valores y propiedades.

        JavaScript est√° dise√±ado en un paradigma simple basado en objetos.
        Un objeto es una colecci√≥n de propiedades, y una propiedad es una asociaci√≥n entre un nombre (o clave) y un valor.
        El valor de una propiedad puede ser una funci√≥n, en cuyo caso la propiedad es conocida como un m√©todo.
        Adem√°s de los objetos que est√°n predefinidos en el navegador, puedes definir tus propios objetos.
        Los objetos son similares a los arreglos (arrays), excepto que en lugar de usar √≠ndices para acceder y modificar sus datos, accedes a los datos en objetos a trav√©s de propiedades (properties).

        Objeto literal

        Se denomina objeto literal al objeto cuyas propiedades est√°n declaradas textualmente en el c√≥digo.
 
    
        const gato = {
        nombre: 'Valiente',
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"]
        }
    
        #
        Acceder a los valores
    
        Notaci√≥n de punto:
    
        console.log(gato.nombre)
        console.log(gato.duerme)
        console.log(gato.enemigos[0]);
    

        Notaci√≥n de corchetes (nos servir√° para recorrerlo):

        console.log(gato['nombre'])
        console.log(gato['edad'])
        console.log(gato["enemigos"][0]);
        

        CRUD (propiedades)

        Crear (create)
        
        gato.color = 'Azul'
        
        Leer (read)
        
        console.log(gato)
        
        Actualizar (update)
        
        gato.edad = 11
        
        Eliminar (delete)
        
        delete gato.duerme
        



        hasOwnProperty:

        A veces es √∫til comprobar si existe o no la propiedad de un objeto dado. Podemos utilizar el m√©todo .hasOwnProperty(propname) para determinar si un objeto tiene una propiedad con ese nombre. .hasOwnProperty() devuelve true o false si se encuentra la propiedad o no.
        
        const gato = {
            nombre: 'Valiente',
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"]
        }
        
        console.log(gato.hasOwnProperty("nombre"))
        console.log(gato.hasOwnProperty("salud"))
        




        Objetos anidados

        const gato = {
            nombre: 'Valiente',
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            otros: {
                amigos: ["Cobarde", "T√≠mido", "Pegajoso"],
                favoritos: {
                    comida: {
                        fria: "salm√≥n",
                        caliente: "pollo"
                    }
                }
            }
        }
        
        Acceder:
        
        console.log(gato.otros.amigos[0])
        console.log(gato.otros.favoritos.comida.fria)






        Encadenamiento opcional

        Optional chaining
    
        El operador de encadenamiento opcional ?. permite leer el valor de una propiedad ubicada dentro de una cadena de objetos conectados sin tener que validar expresamente que cada referencia en la cadena sea v√°lida.
    
        const gato = {
        nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
        };
        console.log(gato.otros.favoritos);
    
        icono visual studio code git
    
        Encadenamiento opcional: resultado undefined.
    
        console.log(gato.otros?.favoritos);
    
        

        Si es un objeto y este objeto es un array o un string no va a llevar parentesis porque es una propiedad.
        Los metodos si llevan parentesis porque llevan parametros.
        Un metodo es una funcion que esta dentro de nuestro objeto.



        Propiedad

        Propiedades:
        
        const frutas = ["sand√≠a", "pera", "melon"];
        console.log(frutas.length);
        
        M√©todos:
        
        const frutas = ["sand√≠a", "pera", "melon"];
        frutas.push("banana");
        console.log(frutas);
        
        icono visual studio code git
        #
        M√©todos
        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer: function () {
                console.log("Ahora est√° comiendo");
            },
        };
        
        gato.comer();
        
        Reducido:
        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer() {
                console.log("Ahora est√° comiendo");
            },
        };
        
        gato.comer();
        
        Con par√°metros:
        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer(comida) {
                return "Ahora est√° comiendo: " + comida;
            },
        };
        
        console.log(gato.comer("pez"));
        
        ¬øQu√© pasar√° con esto?
        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer(comida) {
                return `${nombre} est√° comiendo ${comida}`;
            },
        };
        
        console.log(gato.comer("pez"));
        
        Lo est√° buscando en el objeto global
        
        const nombre = "Ignacio";
        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer(comida) {
                return `${nombre} est√° comiendo ${comida}`;
            },
        };
        
        console.log(gato.comer("pez"));
        





        Objeto this:

        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer(comida) {
                console.log(this);
            },
        };
        
        gato.comer("pez");

        
        #
        this
        
            Veamos una introducci√≥n a this
            this: Hace referencia al objeto contexto de JavaScript en el cual se est√° ejecutando el c√≥digo actual

        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer(comida) {
                return `${this.nombre} est√° comiendo ${comida}`;
            },
        };
        
        console.log(gato.comer("pez"));
        

        Las funciones de flecha las podemos usar dentro de un metodo pero no como un metodo.

        arrow function

        ¬øEsto funcionar√°?
        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer: (comida) => {
                return `${this.nombre} est√° comiendo ${comida}`;
            },
        };
        
        console.log(gato.comer("pez"));
        
        Arrow Functions
        
        No tiene this o super y no se debe usarla como m√©todos.
        
            Funciones Flecha
        
            (opens new window)
        
        Pero si puedo utilizarla en su interior:
        
        const gato = {
            nombre: "Valiente",
            duerme: true,
            edad: 10,
            enemigos: ["agua", "perros"],
            comer(comida) {
                return `${this.nombre} est√° comiendo ${comida}`;
            },
            mostrarEnemigos() {
                return this.enemigos.forEach((item) => console.log(item));
            },
        };
        
        gato.mostrarEnemigos();
        


        for...in

        for in
    
        (opens new window): La instrucci√≥n for-in itera sobre todas las propiedades enumerables de un objeto que est√° codificado por cadenas
    
    const gato = {
        nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
    };
    
    for (const propiedad in gato) {
        console.log(gato[propiedad]);
        console.log(propiedad) <!-- con esta podemos recorrer los nombres de la propiedad-->
    }
    
    #
    ¬øPor qu√© usar for...in?
    
        Dado que for...in est√° construido para iterar propiedades de objeto, no se recomienda su uso con arreglos y opciones como Array.prototype.forEach() y existe for...of, ¬øcu√°l podr√≠a ser el uso de for...in?
        Es posible que se utilice de forma m√°s pr√°ctica con fines de depuraci√≥n, ya que es una forma f√°cil de comprobar las propiedades de un objeto (mediante la salida a la consola o de otro modo)
        Aunque los arreglos suelen ser m√°s pr√°cticos para almacenar datos, en situaciones en las que se prefiere un par clave-valor para trabajar con datos (con propiedades que act√∫an como la "clave"), puede haber casos en los que desees comprobar si alguna de esas claves cumple un valor particular.



        Object.values()

        Object.values()
    
        (opens new window): devuelve un array con los valores correspondientes a las propiedades enumerables de un objeto.
    
        console.log(Object.values(gato));
    
        Con forEach()
    
        Object.values(gato).forEach((item) => console.log(item));
    
        Existen m√°s m√©todos como:
    
        Object.entries()
    
        (opens new window)
        Object.key()
        (opens new window)
        Object.getOwnPropertyNames()



        Destructuring Objects

        desestructuraci√≥n
    
        (opens new window) La sintaxis de desestructuraci√≥n es una expresi√≥n de JavaScript que permite desempacar valores de arreglos o propiedades de objetos en distintas variables.
    
        const gato = {
        nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
        otros: {
            amigos: ["Cobarde", "T√≠mido", "Pegajoso"],
            favoritos: {
                comida: {
                    fria: "salm√≥n",
                    caliente: "pollo",
                    },
                },
            },
        };
    
        const nombreGato = gato.nombre;
        console.log(nombreGato);
    
        Destructuring de objetos:
    
        const gato = {
        nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
        otros: {
            amigos: ["Cobarde", "T√≠mido", "Pegajoso"],
            favoritos: {
                comida: {
                    fria: "salm√≥n",
                    caliente: "pollo",
                    },
                },
            },
        };
    
        const { nombre, duerme, edad, enemigos } = gato;
        console.log(nombre);
        console.log(duerme);
        console.log(edad);
        console.log(enemigos);
    
        Alias:
    
        const { nombre: nombreGato } = gato;
        console.log(nombreGato);
    
        por defecto:
    
        const gato = {
        // nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
        otros: {
            amigos: ["Cobarde", "T√≠mido", "Pegajoso"],
            favoritos: {
                comida: {
                    fria: "salm√≥n",
                    caliente: "pollo",
                    },
                },
            },
        };
    
        const { nombre: nombreGato = "Sin nombre" } = gato;
        console.log(nombreGato);
    
        Anidados:
    
        const gato = {
        nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
        otros: {
            amigos: ["Cobarde", "T√≠mido", "Pegajoso"],
            favoritos: {
                comida: {
                    fria: "salm√≥n",
                    caliente: "pollo",
                    },
                },
            },
        };
    
        const {
        otros: { amigos },
        } = gato;
        console.log(amigos);
    
        Array
    
        La destructuring tambi√©n sirve para Array, solo reemplazar por []
    
        const enemigos = ["agua", "perros"]
        const [agua, perro] = enemigos;
        console.log(agua);
        console.log(perro);
    
        M√©todos:
    
        const gato = {
        nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
        comer(comida) {
            return `${this.nombre} est√° comiendo ${comida}`;
            },
        mostrarEnemigos() {
            return this.enemigos.forEach((item) => console.log(item));
            },
        };
    
        const { comer } = gato;
        console.log(comer("pez"));
    
        // undefined est√° comiendo pez




        Setters y Getters:


        Getters y Setters

        info
    
        (opens new window)
        get
        (opens new window): Enlaza la propiedad de un objeto con una funci√≥n que ser√° llamada cuando la propiedad es buscada.
        set
    
        (opens new window): La sintaxis set asocia la propiedad de un objeto a una funci√≥n que ser√° llamada cuando haya un intento de asignar valor a esa propiedad.
    
        GET: Tenga en cuenta lo siguiente al trabajar con la sintaxis get:
    
        Debe tener exactamente cero parametros.
        No debe haber m√∫ltiples getters para una misma propiedad.
    
        SET: Tenga en cuenta lo siguiente al trabajar con setters:
    
        Debe tener exactamente un par√°mentro
    
        const gato = {
        nombre: "Valiente",
        duerme: true,
        edad: 10,
        enemigos: ["agua", "perros"],
        comer(comida) {
            return `${this.nombre} est√° comiendo ${comida}`;
        },
        get nombreMayuscula() {
            return this.nombre.toUpperCase();
        },
        set nuevoEnemigo(nuevo) {
            this.enemigos.push(nuevo);
        },
        };
    
        // GET
        console.log(gato.nombreMayuscula);
    
        // SET
        gato.nuevoEnemigo = "batman";
        console.log(gato.enemigos);
    



        por valor vs por referencia

        fuente
    
        (opens new window)
        por valor: Cuando asignamos valores primitivos (Boolean, Null, Undefined, Number, String y Symbol), el valor asignado es una copia del valor que estamos asignando.
        por referencia: Pero cuando asignamos valores NO primitivos o complejos (Object, Array y Function), JavaScript copia ‚Äúla referencia‚Äù, lo que implica que no se copia el valor en s√≠, si no una referencia a trav√©s de la cual accedemos al valor original.
    
        Primitivos: (por valor)
    
        let a = "hola";
        let b = a;
        console.log(b);
    
        Si cambiamos el valor de a, b sigue siendo "hola"
    
        a = "chao";
        console.log(b);
    
        abrir snippet vscode
    
        No primitivos: (por referencia)
    
        let a = ["hola"];
        let b = a;
        console.log(b);
    
        let a = ["hola"];
        let b = a;
    
        a.push("chao");
    
        console.log(b);
    
        abrir snippet vscode
    
        Lo mismo pasa con los objetos:
    
        const a = {
        nombre: "hola",
        };
    
        const b = a;
    
        a.nombre = "chao";
    
        console.log(b);
    



        DOM:


        document

        document
    
        (opens new window) La interfaz Document representa cualquer p√°gina web cargada en el navegador y sirve como punto de entrada al contenido de la p√°gina (El √°rbol DOM).
    
        console.log(document);
    
        Algunas propiedades:
    
        (opens new window)
    
        console.log(document.head);
        console.log(document.title);
        console.log(document.body);
        console.log(document.domain);
    
        Algunos m√©todos:
    
        (opens new window)
    
        Document.getElementsByClassName(String className)
        Document.getElementsByTagName(String tagName)
        Document.getElementById(String id)
        Document.querySelector(String selector)
        Document.querySelectorAll(String selector)
        Document.createDocumentFragment()
        Document.createElement(String name)
    
        #
        getElementById
    
        getElementById
    
        (opens new window): Devuelve una referencia al elemento por su ID.
    
        <!DOCTYPE html>
        <html lang="en">
    
        <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        </head>
    
        <body>
    
        <h1 id="tituloWeb">Lorem, ipsum dolor.</h1>
    
        <script src="app.js"></script>
        </body>
    
        </html>
    
        console.log(document.getElementById("tituloWeb"));
        console.log(document.getElementById("tituloWeb").textContent);
        console.log(document.getElementById("tituloWeb").innerHTML);
    
        #
        ¬øqu√© pasa en este caso?
    
        <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="app.js"></script> <!-- Qu√© pasar√°?? -->
        </head>
    
        #
        script, DOMContentLoaded, defer
    
        DOMContentLoaded
    
        (opens new window): el navegador HTML est√° completamente cargado y el √°rbol DOM est√° construido, pero es posible que los recursos externos como <img> y hojas de estilo a√∫n no se hayan cargado.
    
        document.addEventListener("DOMContentLoaded", () => {
        console.log(document.querySelector("h1"));
        });
    
        defer
    
        (opens new window): El atributo defer indica al navegador que no espere por el script. En lugar de ello, debe seguir procesando el HTML, construir el DOM. El script carga ‚Äúen segundo plano‚Äù y se ejecuta cuando el DOM esta completo.
        Los scripts con defer siempre se ejecutan cuando el DOM esta listo (pero antes del evento DOMContentLoaded).
        defer no funciona igual en todos los navegadores.
    
        <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="app.js" defer></script>
        </head>
    
        #
        querySelector
    
        querySelector
    
        (opens new window): Devuelve el primer elemento del documento que coincida con el grupo especificado de selectores.
    
        <h1 class="text-primary" id="tituloWeb">Lorem, ipsum dolor.</h1>
    
        console.log(document.querySelector("h1"));
        console.log(document.querySelector(".text-primary"));
        console.log(document.querySelector("#tituloWeb"));
    
        Otro ejemplo:
    
        <div class="container">
        <p class="text-danger">Lorem, ipsum dolor.</p>
        <p class="text-danger">Lorem, ipsum dolor.</p>
        <p class="text-danger">Lorem, ipsum dolor.</p>
        </div>
    
        <p class="text-danger">parrafo volando</p>
    
        // El primer elemento que encuentre
        console.log(document.querySelector(".text-danger"));
    
        // Todos
        console.log(document.querySelectorAll(".text-danger"));
    
        // Todo lo que est√© en "container"
        console.log(document.querySelectorAll(".container .text-danger"));
    
        #
        querySelector vs getElementById
    
        El m√©todo querySelector le permite recuperar un elemento mediante una consulta de selector de CSS
        El m√©todo getElementById recupera un elemento por su ID DOM.
        Ambos m√©todos tienen una amplia compatibilidad con los navegadores. Debe optar por usar el m√©todo querySelector si necesita seleccionar elementos usando reglas m√°s complejas que se representan f√°cilmente usando un selector CSS. Si desea seleccionar un elemento por su ID, usar getElementById es una buena opci√≥n.
        fuente
    
        (opens new window)
        A menudo necesitar√° realizar selecciones m√°s complejas en su HTML, y ah√≠ es donde querySelector puede ser m√°s √∫til; usarlo de manera constante tambi√©n puede hacer que su c√≥digo sea m√°s f√°cil de leer para otros codificadores.
        En otras palabras, el principal beneficio de usar querySelector o querySelectorAll es que podemos seleccionar elementos usando selectores CSS, lo que nos da una forma uniforme de manejar la selecci√≥n de elementos, y eso lo convierte en una forma preferida de seleccionar elementos para muchos desarrolladores.
        Si usa una herramienta como Babel para admitir navegadores m√°s antiguos, entonces puede ser irrelevante, ya que las funciones m√°s nuevas se pueden convertir a c√≥digo compatible con versiones anteriores cuando compila su script.
        800.000 selecciones por segundo, querySelector es aprox. 6% m√°s lento.
        fuente
    
        (opens new window)
    
        <div id="container">
        <p class="text-danger">Lorem, ipsum dolor.</p>
        <p class="text-danger">Lorem, ipsum dolor.</p>
        <p class="text-danger">Lorem, ipsum dolor.</p>
        </div>
    
        <p>parrafo volando</p>
    
        console.log(document.querySelectorAll("div p"));
    
        </p>



        Elementos:


        element

        element
    
        (opens new window): eventos disponibles para los elementos HTML
    
        Algunas propiedades:
    
        const h1 = document.querySelector("#tituloWeb");
    
        console.log(h1.className);
        console.log(h1.id);
        console.log(h1.style);
        console.log(h1.tagName);
        console.log(h1.textContent);
    
        h1.textContent = "nuevo texto";
        h1.style.backgroundColor = "red";
        h1.style.color = "white";
    
        Algunos m√©todos:
    
        (opens new window)
    
        addEventListener: Registra un controlador de evento para un tipo de evento espec√≠fico en un elemento.
        appendChild: Inserta un nodo as√≠ como el √∫ltimo nodo hijo de este elemento.
        hasAttributes: Verifica si el elemento tiene o no alg√∫n atributo.



        Eventos:

        Eventos

        En JavaScript, la interacci√≥n con el usuario se consigue mediante la captura de los eventos que √©ste produce. Un evento es una acci√≥n del usuario ante la cual puede realizarse alg√∫n proceso (por ejemplo, el cambio del valor de un formulario, o la pulsaci√≥n de un enlace).
        #
        addEventListener
        
            addEventListener
        
        (opens new window): Registra un evento a un objeto en espec√≠fico.
        El Objeto especifico puede ser un simple elemento en un archivo, el mismo documento , una ventana o un XMLHttpRequest.
        Eventos est√°ndar
        
            (opens new window)
        
        target.addEventListener(tipo, listener);
        
            tipo: tipo de evento a escuchar.
            listener: El objeto que recibe una notificaci√≥n cuando un evento de el tipo especificado ocurre. Debe ser un objeto implementando la interfaz EventListener o solo una function en JavaScript.
        
        #
        click
        
        <button id="boton">Cambiar texto</button>
        <p id="parrafo">Lorem, ipsum dolor.</p>
        
        const boton = document.querySelector("#boton");
        const parrafo = document.querySelector("#parrafo");
        
        boton.addEventListener("click", () => {
            parrafo.textContent = "Nuevo texto desde evento";
        });
        


        Pr√°ctica:

        Intenta hacer esto
    
        (opens new window)
    
        <!DOCTYPE html>
        <html lang="es">
    
        <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Seleccionar Color</title>
        <link
          crossorigin="anonymous"
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
          rel="stylesheet"
        >
        </head>
    
        <body>
    
        <div class="container mt-5 text-center">
            <label
              class="form-label"
              for="inputColor"
            >Color picker</label>
            <input
              id="inputColor"
              class="form-control form-control-color mb-3 w-100"
              title="Seleccione un color"
              type="color"
              value="#563d7c"
            >
            <button
              id="boton"
              class="btn btn-primary w-100"
            >Visualizar</button>
        </div>
        <div class="container mt-5">
    
            <p
              id="textoHexa"
              class="lead text-center"
            >#563d7c</p>
            <div
              id="cardColor"
              class="card text-center p-5"
              style="background-color: #563d7c;"
            ></div>
        </div>
    
        <script src="app.js"></script>
        </body>
    
        </html>
    
        const inputColor = document.getElementById("inputColor");
        const boton = document.getElementById("boton");
        const textoHexa = document.getElementById("textoHexa");
        const cardColor = document.getElementById("cardColor");
    
        console.log(inputColor.value);
    
        boton.addEventListener("click", () => {
        console.log(inputColor.value);
        textoHexa.textContent = inputColor.value;
        cardColor.style.backgroundColor = inputColor.value;
        });
    
        #
        bonus opcional
    
        Copiar color en el portapapeles:
    
        boton.addEventListener("click", () => {
        console.log(inputColor.value);
        textoHexa.textContent = inputColor.value;
        cardColor.style.backgroundColor = inputColor.value;
        navigator.clipboard
            .writeText(inputColor.value)
            .then(() => console.log("texto copiado"))
            .catch((e) => console.log(e));
        });


        createElement:

        createElement

        createElement
    
        (opens new window): El m√©todo document.createElement() crea un elemento HTML especificado por su tagName.
    
        Crear un <li>
    
        const li = document.createElement("li");
        li.textContent = "item desde javascript";
        console.log(li)
    
        #
        appendChild
    
        appendChild
    
        (opens new window): Agrega un nuevo nodo al final de la lista de un elemento hijo de un elemento padre especificado.
    
        <ul id="listaDinamica">
        <li>Elemento est√°tico</li>
        </ul>
    
        // elemento donde vamos a incorporar los <li>
        const listaDinamica = document.querySelector("#listaDinamica");
    
        // Creamos el <li>
        const li = document.createElement("li");
    
        // // Agregamos texto al <li>
        li.textContent = "item desde javascript";
    
        // // Finalmente incorporamos al <ul>
        listaDinamica.appendChild(li);
        listaDinamica.appendChild(li); // ¬øqu√© pas√≥ aqu√≠?
    
        WARNING
    
        Si el child hace una referencia a un nodo existente en el documento, el m√©todo appendChild se mueve de su posici√≥n actual a su nueva posici√≥n.
        √âsto significa que el nodo no puede estar en dos puntos del documento de manera simult√°nea.
        As√≠ que si el nodo ya contiene un padre, primero es eliminado, y despu√©s se a√±ade a la nueva posici√≥n.
        Se puede usar Node.cloneNode
    
        (opens new window) para hacer una copia del nodo antes de a√±adirlo debajo de su nuevo elemento padre.
    
        No recomendado:
    
        const listaDinamica = document.querySelector("#listaDinamica");
    
        const arrayElementos = ["Per√∫", "Bolivia", "Colombia"];
    
        arrayElementos.forEach((pais) => {
        const li = document.createElement("li");
        li.textContent = pais;
        listaDinamica.appendChild(li);
        });
    
        No recomendado:
    
        arrayElementos.forEach((pais) => {
        listaDinamica.innerHTML += `
        <li>${pais}</li>
        `;
        });
    
        Reflow
    
        Aqu√≠ se genera Reflow:
        (opens new window) Ocurre cuando un navegador debe procesar y dibujar parte o la totalidad de una p√°gina web nuevamente, como despu√©s de una actualizaci√≥n en un sitio interactivo.
    


        Fragment

        new DocumentFragment()
    
        (opens new window)
        createDocumentFragment()
    
        (opens new window)
        La interfaz DocumentFragment representa un objeto de documento m√≠nimo que no tiene padre.
        Se utiliza como una versi√≥n ligera de Document que almacena un segmento de una estructura de documento compuesta de nodos como un documento est√°ndar.
        La gran diferencia se debe al hecho de que el fragmento de documento no forma parte de la estructura de √°rbol del documento activo.
        Los cambios realizados en el fragmento no afectan el documento (incluso en reflow) ni inciden en el rendimiento cuando se realizan cambios.
    
        const listaDinamica = document.querySelector("#listaDinamica");
    
        const arrayElementos = ["Per√∫", "Bolivia", "Colombia"];
    
        const fragment = document.createDocumentFragment(); // new DocumentFragment()
    
        arrayElementos.forEach((pais) => {
        const li = document.createElement("li");
        li.textContent = pais;
        fragment.appendChild(li);
        });
    
        listaDinamica.appendChild(fragment);
    


        inserBefore:


        insertBefore

        firstChild
    
        (opens new window)
        insertBefore
    
        (opens new window)
    
        parentNode.insertBefore(newNode, referenceNode);
    
        arrayElementos.forEach((pais) => {
        const newNode = document.createElement("li");
        newNode.textContent = pais;
    
        // Nos devuelve el primer elemento
        const referenceNode = fragment.firstChild;
    
        // En caso de que no exista un nodo hijo tirar√° null
        console.log("primer newNode", referenceNode);
    
        // fragment.insertBefore(newNode, referenceNode);
        // Si "referenceNode" es null, el newNode se insertar√° al final de la lista.
        fragment.insertBefore(newNode, referenceNode);
        });
    


        Pr√°ctica createElement

        Supongamos que necesitamos incorporar de forma din√°mica este elemento:
    
        <li class="list">
        <b>Pa√≠s: </b> <span class="text-primary">aqu√≠ va el pa√≠s</span>
        </li>
    
        const listaDinamica = document.querySelector("#listaDinamica");
    
        const arrayElementos = ["Per√∫", "Bolivia", "Colombia"];
    
        const fragment = new DocumentFragment();
    
        arrayElementos.forEach((pais) => {
        const li = document.createElement("li");
        li.className = "list";
    
        const bold = document.createElement("b");
        bold.textContent = "Pa√≠s: ";
    
        const span = document.createElement("span");
        span.className = "text-primary";
        span.textContent = pais;
    
        li.appendChild(bold);
        li.appendChild(span);
        fragment.appendChild(li);
        });
    
        listaDinamica.appendChild(fragment);
    
        innerHTML
    
        let template = "";
    
        arrayElementos.forEach((pais) => {
        template += `
        <li class="list">
            <b>Pa√≠s: </b> <span class="text-primary">${pais}</span>
        </li>
        `;
        });
    
        listaDinamica.innerHTML = template;
    
        innerHTML vs createElement
    
        Ojo que aqu√≠ estamos reemplazando fragment por let template, por ende hace un efecto    parecido y minimizamos el reflow, ya que solo una vez que tenemos nuestro  templateString listo, lo incorporamos al HTML.
    
        ¬°Alerta de spoiler! no utilizaremos este m√©todo



        Crear snippet

        snippet
    
        (opens new window)
    
        ctrl + shift + p
    
        abrir snippet vscode
        abrir snippet vscode
    
        "Template in HTML": {
        "prefix": "template",
        "body": ["<template>$1</template>"],
        "description": "Agrega el template en html"
        }
    
        #
        template
    
        template
    
        (opens new window): es un mecanismo para mantener el contenido HTML del lado del cliente que no se renderiza cuando se carga una p√°gina, pero que posteriormente puede ser instanciado durante el tiempo de ejecuci√≥n empleando JavaScript.
        Piensa en la plantilla como un fragmento de contenido que est√° siendo almacenado para un uso posterior en el documento.
        El analizador procesa el contenido del elemento <template> durante la carga de la p√°gina, pero s√≥lo lo hace para asegurar que esos contenidos son v√°lidos; sin embargo, estos contenidos del elemento no se renderizan.
        los elementos <template> contienen un DocumentFragment en su propiedad HTMLTemplateElement.content.
    
        <ul id="listaDinamica"></ul>
    
        <template id="liTemplate">
        <li class="list">
            <b>Pa√≠s: </b> <span class="text-primary"></span>
        </li>
        </template>
    
        <script src="app.js"></script>
    
        const listaDinamica = document.querySelector("#listaDinamica");
    
        const liTemplate = document.querySelector("#liTemplate");
        // es aconsejable clonar
        const clone = liTemplate.content.cloneNode(true);
    
        clone.querySelector("span").textContent = "Per√∫";
    
        listaDinamica.appendChild(clone);
    
        Fragment + Template
    
        const listaDinamica = document.querySelector("#listaDinamica");
    
        const arrayElementos = ["Per√∫", "Bolivia", "Colombia"];
    
        const fragment = document.createDocumentFragment();
        const liTemplate = document.querySelector("#liTemplate");
    
        arrayElementos.forEach((pais) => {
        const clone = liTemplate.content.cloneNode(true);
        clone.querySelector("span").textContent = pais;
        fragment.appendChild(clone);
        });
    
        listaDinamica.appendChild(fragment);
    
        TIP
    
        HTMLTemplateElement tiene una propiedad content, que es de solo lectura y DocumentFragment contiene el sub√°rbol DOM que representa la plantilla. Tenga en cuenta que el uso directo del valor de content podr√≠a provocar un comportamiento inesperado; consulte la secci√≥n Evitar el error de DocumentFragment a continuaci√≥n
    
        (opens new window).
    
        const listaDinamica = document.querySelector("#listaDinamica");
        const arrayElementos = ["Per√∫", "Bolivia", "Colombia"];
        const fragment = document.createDocumentFragment();
        const liTemplate = document.querySelector("#liTemplate");
    
        const clickPais = (e) => console.log("evento", e.target);
    
        arrayElementos.forEach((pais) => {
        const clone = liTemplate.content.firstElementChild.cloneNode(true);
        clone.querySelector("span").textContent = pais;
    
        clone.addEventListener("click", clickPais);
    
        fragment.appendChild(clone);
        });
    
        listaDinamica.appendChild(fragment);
    
        const clickPais = (e) => e.target.append(" click");
    





        Pr√°ctica template

        ver ejemplo

        (opens new window)

        <!DOCTYPE html>
        <html lang="es">

        <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Carrito Objeto</title>
        <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet">
        </head>

        <body>

        <main class="container mt-5">
        <div class="row text-center">
            <article class="col-sm-4 mb-3">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Frutilla üçì</h5>
                        <button class="btn btn-primary" data-fruta="frutilla">Agregar</button>
                    </div>
                </div>
            </article>
            <article class="col-sm-4 mb-3">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Banana üçå</h5>
                        <button class="btn btn-primary" data-fruta="banana">Agregar</button>
                    </div>
                </div>
            </article>
            <article class="col-sm-4 mb-3">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Manzana üçè</h5>
                        <button class="btn btn-primary" data-fruta="manzana">Agregar</button>
                    </div>
                </div>
            </article>
        </div>
        </main>

        <section class="container mt-3">
        <ul class="list-group" id="carrito">
            <!-- <li class="list-group-item d-flex justify-content-between align-items-center">
                <span class="lead">A list item</span>
                <span class="badge bg-primary rounded-pill">14</span>
            </li> -->
        </ul>
        </section>

        <template id="template">
        <li class="list-group-item d-flex justify-content-between align-items-center">
            <span class="lead">A list item</span>
            <span class="badge bg-primary rounded-pill">14</span>
        </li>
        </template>

        <script src="app.js"></script>
        </body>

        </html>

        const carrito = document.querySelector("#carrito");
        const template = document.querySelector("#template");
        const fragment = document.createDocumentFragment();
        const agregar = document.querySelectorAll(".card button");

        const carritoObjeto = {};

        const agregarCarrito = (e) => {
        // console.log(e.target.dataset);
        // console.log(e.target.dataset.fruta);

        const producto = {
        titulo: e.target.dataset.fruta,
        id: e.target.dataset.fruta,
        cantidad: 1,
        };

        if (carritoObjeto.hasOwnProperty(producto.id)) {
        producto.cantidad = carritoObjeto[producto.id].cantidad + 1;
        }

        carritoObjeto[producto.id] = producto;

        pintarCarrito();
        };

        agregar.forEach((boton) => boton.addEventListener("click", agregarCarrito));

        const pintarCarrito = () => {
        carrito.textContent = "";

        Object.values(carritoObjeto).forEach((item) => {
        const clone = template.content.cloneNode(true);
        clone.querySelector(".lead").textContent = item.titulo;
        clone.querySelector(".rounded-pill").textContent = item.cantidad;
        fragment.appendChild(clone);
        });
        carrito.appendChild(fragment);
        };



        Array Methods:


        Javascript (Array methods)

        Sigamos descubriendo m√©todos de los array, muy pero muuuuuuuy √∫tiles ü§ô.
        Estos m√©todos no mutan el array original, sino que nos devuelven uno nuevo.
        functional programming
    
        (opens new window)
    
        ¬øQuieres apoyar los directos? üòç
    
        Tienes varias jugosas alternativas:
    
        Suscr√≠bete al canal de Youtube (es gratis) click aqu√≠
    
        (opens new window)
        Si est√°s viendo un video no olvides regalar un üëç like y comentario üôèüèº
        Tambi√©n puedes ser miembro del canal de Youtube click aqu√≠
        (opens new window)
        Puedes adquirir cursos premium en Udemy üëáüèºüëáüèºüëáüèº ¬øQui√©res apoyar los directos?
    
        Curso de HTML + CSS + Bootstrap 5 + Git y m√°s UDEMY
    
        (opens new window)
        Curso de React + Firebase UDEMY
        (opens new window)
        Curso Vue.js + Firebase UDEMY
    
            (opens new window)
    
        Hoy vamos a conocer:
    
        map
        find
        filter
        reduce
    
        TIP
    
        La programaci√≥n funcional es otro enfoque com√∫n en el desarrollo de software (paradigma de programaci√≥n). En programaci√≥n funcional, el c√≥digo est√° organizado en funciones m√°s peque√±as y b√°sicas que se pueden combinar para construir programas de mayor complejidad.
    
        Pero antes... ¬øqu√© es un paradigma de programaci√≥n?
        #
        Paradigmas de programaci√≥n JS
    
        JavaScript es un lenguaje de "m√∫ltiples paradigmas".
    
        WARNING
    
        La gu√≠a no es t√©cnica, por ende se tratar√© de simplificar las definiciones, gui√°ndome de art√≠culos y mi bla bla bla.
        #
        Fuentes:
    
        que es paradigma
    
        (opens new window)
        pensemosweb
        (opens new window)
        wikipedia
        (opens new window)
        ichi.pro
        (opens new window)
        cosasdigitales
        (opens new window)
        declarative and imperative
    
        (opens new window)
    
        #
        ¬øQu√© es un paradigma de programaci√≥n?
    
        Un paradigma de programaci√≥n no es m√°s que una forma de ver y crear c√≥digo de programaci√≥n. Para resolver problemas.
        Existen diferentes formas de dise√±ar un lenguaje de programaci√≥n y varios modos de trabajar para obtener los resultados que necesitan los programadores.
        Los lenguajes de programaci√≥n adoptan uno o varios paradigmas en funci√≥n del tipo de √≥rdenes que permiten implementar como, por ejemplo, Python o JavaScript, que son multiparadigmas.
    
        Los paradigmas de programaci√≥n comunes incluyen:
    
        Imperativo: (Emperador) en el que el programador instruye a la m√°quina c√≥mo cambiar su estado.
            procedimental que agrupa las instrucciones en procedimientos.
            orientado a objetos (OPP o POO) que agrupa las instrucciones con la parte del estado en el que operan.
        Declarativo: en el que el programador simplemente declara las propiedades del resultado deseado, pero no c√≥mo calcularlo.
            funcional en el que el resultado deseado se declara como el valor de una serie de aplicaciones de funci√≥n.
            l√≥gico en la que el resultado deseado se declara como la respuesta a una pregunta sobre un sistema de hechos y reglas.
            matem√°tico en el que el resultado deseado se declara como la soluci√≥n de un problema de optimizaci√≥n.
            reactivo en el que se declara el resultado deseado con flujos de datos y la propagaci√≥n del cambio.
    
        #
        Imperativa vs Declarativa
    
        Programaci√≥n imperativa: Nosotros dictamos el camino a seguir a trav√©s del control de flujo: variables, funciones, if, else, switch, loops ( while, for, for of, for in), try catch, async await. Por lo tanto siempre utilizas programaci√≥n imperativa en Javascript.
        Programaci√≥n declarativa: Declaras lo que quieres que suceda, no c√≥mo se hace. La programaci√≥n funcional b√°sicamente significa escribir c√≥digo que hace algo (declara lo que se hace) pero no es espec√≠fico sobre c√≥mo hacerlo (imperativo).
    
        TIP
    
        Javascript permite un estilo de desarrollo tanto declarativo como imperativo, atendiendo asi a qu√© objetivo se busca alcanzar (declarativo) o extendi√©ndose sobre c√≥mo se debe alcanzar un objetivo (imperativo).
        Si bien las √∫ltimas incorporaciones del lenguaje muestran una tendencia hacia un paradigma claramente declarativo (funcional), ambos estilos coexisten en la industria actual y suponen diferencias a efectos de optimizaci√≥n, rendimiento, legibilidad o mantenibilidad de nuestras aplicaciones, entre otros.
        Ambos enfoques pueden lograr los mismos objetivos, y no tenemos que elegir solo uno al programar porque JavaScript es un lenguaje de "m√∫ltiples paradigmas"
    
        #
        POO
    
        La programaci√≥n orientada a objetos es una forma de programaci√≥n imperativa puesto que al programar se describe la secuencia que debe seguir el programa para resolver un problema dado.
        Hace uso de estructuras de datos llamadas objetos que aglutinan propiedades y m√©todos conjuntamente con sus interacciones.
        La programaci√≥n orientada a objetos se basa tambi√©n en conceptos como la abstracci√≥n de datos, la encapsulaci√≥n, los eventos, la modularidad, la herencia y el polimorfismo.
        Se viene una secci√≥n dedicada a POO (paciencia üôè)
    
        #
        Funcional
    
        La programaci√≥n funcional b√°sicamente significa escribir c√≥digo que hace algo (declara lo que se hace) pero no es espec√≠fico sobre c√≥mo hacerlo (imperativo).
    
        Video recomendado
    
        (opens new window)
        curso recomendado EDteam
    
        (opens new window)
    
        #
        Conclusiones
    
        Con js podemos utilizar m√∫ltiples paradigmas, por ende, conoceremos algunos m√©todos que nos facilitan la vida para la programaci√≥n declarativa (funcional) pero seguiremos mezclando nuestra escritura con programaci√≥n imperativa




        <!-- TECLA WINDOWS + . PARA PONER EMOJIS -->


        Array methods

        Sigamos descubriendo m√©todos de los array muy pero muuuuuuuy √∫tiles!
        Estos m√©todos no mutan el array original, sino que nos devuelven uno nuevo.
        functional programming
    
        (opens new window)
    
        #
        map
    
        map
    
        (opens new window): El m√©todo map iterar√° sobre cada elemento de un arreglo y devuelve un nuevo arreglo que contiene los resultados de llamar a la funci√≥n callback en cada elemento. Esto lo hace sin mutar el arreglo original.
    
        TIP
    
        Una funci√≥n de callback es una funci√≥n que se pasa a otra funci√≥n como un argumento, que luego se invoca dentro de la funci√≥n externa para completar alg√∫n tipo de rutina o acci√≥n.
    
        Chiste repetido: Secci√≥n especial m√°s adelante con callback ü§ô
    
        Cuando se utiliza la funci√≥n callback, se pasan tres argumentos. El primer argumento es el elemento actual que se est√° procesando. El segundo es el √≠ndice de ese elemento y el tercero es el arreglo al que se llam√≥ el m√©todo map.
    
        const frutas = ["üçå", "üçè", "üçì"];
    
        const nuevoArray = frutas.map((item) => {
        return item;
        });
    
        console.log(nuevoArray);
    
        Reduciendo el c√≥digo:
    
        const frutas = ["üçå", "üçè", "üçì"];
        const nuevoArray = frutas.map((item) => item);
        console.log(nuevoArray);
    
        ¬øPero no es lo mismo que esto?
    
        const frutas = ["üçå", "üçè", "üçì"];
        // por referencia (revisar videos anteriores)
        const arrayReferencia = frutas; 
        frutas.push("üçâ");
        console.log(arrayReferencia);
    
        // construye un nuevo array con los resultados
        // esto lo hace sin mutar el arreglo original
        const nuevoArray = frutas.map((item) => item);
        frutas.push("üçâ");
        console.log(nuevoArray);
    
        Devolver solo el name en un nuevo array
    
        onst users = [
        { name: "John", age: 34 },
        { name: "Amy", age: 20 },
        { name: "camperCat", age: 10 },
        ];
    
        const names = users.map((user) => user.name);
        console.log(names);
    
        Devolver nuevo array con numeros * 2
    
        const numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
        const numerosPorDos = numeros.map((item) => item * 2);
    
        console.log(numerosPorDos);
    
        #
        filter
    
        filter
    
        (opens new window): El m√©todo filter() crea un nuevo array con todos los elementos que cumplan la condici√≥n implementada por la funci√≥n dada.
    
        const users = [
        { uid: 1, name: "John", age: 34 },
        { uid: 2, name: "Amy", age: 20 },
        { uid: 3, name: "camperCat", age: 10 },
        ];
    
        const mayor = users.filter((user) => user.age > 30);
        console.log(mayor);
    
        Eliminar un usuario por uid
    
        const users = [
        { uid: 1, name: "John", age: 34 },
        { uid: 2, name: "Amy", age: 20 },
        { uid: 3, name: "camperCat", age: 10 },
        ];
    
        const userFiltrado = users.filter((user) => user.uid !== 2);
    
        console.log(userFiltrado);
    
        #
        find
    
        find
    
        (opens new window): El m√©todo find() devuelve el valor del primer elemento del array que cumple la funci√≥n de prueba proporcionada.
    
        Buscar usuario por uid:
    
        const users = [
        { uid: 1, name: "John", age: 34 },
        { uid: 2, name: "Amy", age: 20 },
        { uid: 3, name: "camperCat", age: 10 },
        ];
    
        const amy = users.find((user) => user.uid === 2);
        console.log(amy);
    
        Utilizando destructuring
    
        (opens new window)
    
        const { age } = users.find((user) => user.uid === 2);
        console.log(age);
    
        #
        some
    
        some
    
        (opens new window): El m√©todo some() comprueba si al menos un elemento del array cumple con la condici√≥n implementada por la funci√≥n proporcionada.
    
        const users = [
        { uid: 1, name: "John", age: 34 },
        { uid: 2, name: "Amy", age: 20 },
        { uid: 3, name: "camperCat", age: 10 },
        ];
    
        const existe = users.some((user) => user.uid === 2);
        console.log(existe);
    
        #
        findIndex
    
        findIndex
    
        (opens new window): El m√©todo findIndex() devuelve el √≠ndice del primer elemento de un array que cumpla con la funci√≥n de prueba proporcionada. En caso contrario devuelve -1.
    
        const users = [
        { uid: 1, name: "John", age: 34 },
        { uid: 2, name: "Amy", age: 20 },
        { uid: 3, name: "camperCat", age: 10 },
        ];
    
        const existe = users.findIndex((user) => user.uid === 4);
        console.log(existe);



        slice

        slice
    
        (opens new window): El m√©todo slice() devuelve una copia de una parte del array dentro de un nuevo array empezando por inicio hasta fin (fin no incluido). El array original no se modificar√°.
    
        const arr = ["Cat", "Dog", "Tiger", "Zebra"];
        //             0     [1      2]        3
        const newArray = arr.slice(1, 3);
    
        console.log(newArray);
    
        #
        concat
    
        concat
    
        (opens new window): El m√©todo concat() se usa para unir dos o m√°s arrays. Este m√©todo no cambia los arrays existentes, sino que devuelve un nuevo array.
    
        const array1 = ["a", "b", "c"];
        const array2 = ["d", "e", "f"];
        const array3 = array1.concat(array2);
    
        console.log(array3);
    
        Spread syntax
    
        (opens new window): permite a un elemento iterable tal como un arreglo o cadena ser expandido en lugares donde son esperados.
    
        const array1 = ["a", "b", "c"];
        const array2 = ["d", "e", "f"];
        const array3 = [...array1, ...array2];
    
        console.log(array3);
    




        reduce

        reduce
    
        (opens new window): El m√©todo reduce() ejecuta una funci√≥n reductora sobre cada elemento de un array, devolviendo como resultado un √∫nico valor.
    
        Sumar todos los n√∫meros:
    
        const numeros = [1, 2, 3, 4, 5];
    
        const sumaTodos = numeros.reduce((acc, valorActual) => acc + valorActual);
    
        console.log(sumaTodos);
    
        Aplanar matrices anidadas #01:
    
        const arrayNumeros = [
        [0, 1],
        [2, 3],
        [4, 5],
        ];
        
        const soloNumeros = arrayNumeros.reduce(
        (acc, current) => acc.concat(current)
        );
    
        console.log(soloNumeros);
    
        Aplanar matrices anidadas #02:
    
        const flatSingle = [].concat(...arrayNumeros);
        console.log(flatSingle);
    
        Aplanar matrices anidadas #03: flat()
    
        (opens new window)
    
        const flatSingle = arrayNumeros.flat();
        console.log(flatSingle);
    
        const arrayNumeros = [1, 2, [3, 4, [5, 6]]];
    
        const arrayPlano = arrayNumeros.flat(2);
        console.log(arrayPlano);
    
        #
        split
    
        split: El m√©todo split() divide un objeto de tipo String en un array, mediante un separador.
    
        const cadenaMeses = "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec";
    
        const arrayMeses = cadenaMeses.split(",");
        console.log(arrayMeses);
    
        #
        join
    
        join
    
        (opens new window): el m√©todo join() une todos los elementos de una matriz (o un objeto similar a una matriz) en una cadena y devuelve esta cadena.
    
        const cadenaMeses = "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec";
    
        const arrayMeses = cadenaMeses.split(",");
        console.log(arrayMeses);
    
        const nuevamenteString = arrayMeses.join(",");
        console.log(nuevamenteString);
    
        Separador: Es una cadena usada para separar cada uno de los elementos del arreglo. El separador es convertido a una cadena si es necesario. Si este se omite, los elementos del arreglo son separados con una coma (",")




        Pr√°ctica #01:

        const carrito = document.querySelector("#carrito");
        const template = document.querySelector("#template");
        const fragment = document.createDocumentFragment();
        const agregar = document.querySelectorAll(".card button");

        const carritoArray = [];

        const agregarCarrito = (e) => {
        const producto = {
        titulo: e.target.dataset.fruta,
        id: e.target.dataset.fruta,
        cantidad: 1,
        };

        // buscamos el indice
        const index = carritoArray.findIndex((item) => item.id === producto.id);

        // si no existe empujamos el nuevo elemento
        if (index === -1) {
        carritoArray.push(producto);
        } else {
        // en caso contrario aumentamos su cantidad
        carritoArray[index].cantidad++;
        }

        console.log(carritoArray);

        pintarCarrito();
        };

        agregar.forEach((boton) => boton.addEventListener("click", agregarCarrito));

        const pintarCarrito = () => {
        carrito.textContent = "";

        // recorremos el carrito y pintamos elementos:
        carritoArray.forEach((item) => {
        const clone = template.content.cloneNode(true);
        clone.querySelector(".lead").textContent = item.titulo;
        clone.querySelector(".rounded-pill").textContent = item.cantidad;
        fragment.appendChild(clone);
        });
        carrito.appendChild(fragment);
        };


        El burbujeo y la captura

        events
    
        (opens new window)
        addEventListener
    
        (opens new window)
    
        El burbujeo y la captura de eventos son dos mecanismos que describen lo que sucede cuando dos controladores del mismo tipo de evento se activan en un elemento.
    
        <div class="container">
        <div class="border border-primary border-5 py-5 m-3">
            Lorem, ipsum dolor
            <div class="border border-secondary border-5 py-5 m-3">
                Lorem, ipsum dolor
                <div class="border border-danger border-5 py-5 m-3">
                    Lorem, ipsum dolor
                </div>
            </div>
        </div>
        </div>
    
        Fase de burbuja (bubbling): Se propaga desde el elemento hijo hasta el padre. (comportamiento por defecto)
    
        const primary = document.querySelector(".border-primary");
        const secondary = document.querySelector(".border-secondary");
        const danger = document.querySelector(".border-danger");
    
        primary.addEventListener("click", (e) => console.log("primary"));
        secondary.addEventListener("click", (e) => console.log("secondary"));
        danger.addEventListener("click", (e) => console.log("danger"));
    
        Fase de captura: Se propaga desde el elemento padre hasta el hijo.
    
        primary.addEventListener("click", (e) => console.log("primary"), true);
        secondary.addEventListener("click", (e) => console.log("secondary"), true);
        danger.addEventListener("click", (e) => console.log("danger"), true);
    
        #
        stopPropagation
    
        stopPropagation
    
        (opens new window): evita la propagaci√≥n adicional del evento actual en las fases de captura y bubbling.
    
        const cajas = document.querySelectorAll(".container div");
        cajas.forEach((item) => {
        item.addEventListener("click", (e) => {
            e.stopPropagation();
            console.log("click");
        });
        });
    
        #
        preventDefault
    
        preventDefault
    
        (opens new window): Cancela el evento si este es cancelable, sin detener el resto del funcionamiento del evento, es decir, puede ser llamado de nuevo.
    
        <form>
        <input type="text" name="nombre">
        <button type="submit">Enviar</button>
        </form>
    
        const formulario = document.querySelector("form");
        formulario.addEventListener("submit", (e) => {
        e.preventDefault();
        console.log("click");
        });
    
        TIP
    
        En las siguientes secciones veremos un especial de formularios con sus respectivas validaciones.
    
        Sirve para cualquier comportamiento por defecto del navegador:
    
        <a href="#">ancla</a>
    
        const ancla = document.querySelector("a");
        ancla.addEventListener("click", (e) => e.preventDefault());
    
        #
        Delegaci√≥n de Eventos
    
        La delegaci√≥n de eventos es b√°sicamente un patr√≥n para manejar eventos de manera eficiente.
    
        En lugar de agregar un detector de eventos a todos y cada uno de los elementos similares, podemos agregar un detector de eventos a un elemento principal y llamar a un evento en un objetivo en particular utilizando la propiedad .target del objeto de evento.
    
        As√≠ evitamos la propagaci√≥n üëå
    
        <div class="container">
        <div
          id="padre"
          class="border border-primary border-5 py-5 m-3"
          data-div="divPadre"
        >
            Lorem, ipsum.
            <div
              id="hijo"
              class="border border-secondary border-5 py-5 m-3"
              data-div="divHijo"
            >
                Lorem, ipsum.
                <div
                  id="nieto"
                  class="border border-danger border-5 py-5 m-3"
                  data-div="divNieto"
                >
                    Lorem, ipsum.
                </div>
            </div>
        </div>
        </div>
    
        const container = document.querySelector(".container");
        container.addEventListener("click", (e) => {
        console.log(e.target);
        });
    
        ¬øPero como activo un evento para un elemento en espec√≠fico?
    
        matches
    
        (opens new window): El m√©todo matches() comprueba si el Element ser√≠a seleccionable por el selector CSS especificado en la cadena; en caso contrario, retorna false.
        dataset
    
        (opens new window)
    
        const container = document.querySelector(".container");
        container.addEventListener("click", (e) => {
    
        // console.log(e.target.id);
        if (e.target.id === "hijo") {
            console.log("diste click en el mijo");
        }
    
        // console.log(e.target.matches(".border-danger"));
        if (e.target.matches(".border-danger")) {
            console.log("diste click en el nieto");
        }
    
        // data-set
        // console.log(e.target.dataset["div"]);
        // console.log(e.target.dataset.div);
        if (e.target.dataset["div"] === "divPadre") {
            console.log("diste click en padre");
        }
        });
    
        TIP
    
        Puedes seleccionar todo el document, as√≠ no tienes que estar detectando el componente principal ü§ô
    
        document.addEventListener()
    



        Pr√°ctica

    ver ejemplo

    (opens new window)

        <!-- <!DOCTYPE html>
        <html lang="es">

        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Carrito Objeto</title>
            <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
                integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet">
        </head>

        <body>

            <main class="container mt-5">
                <div class="row text-center">
                    <article class="col-sm-4 mb-3">
                        <div class="card">
                            <div class="card-body">
                                <h5 class="card-title">Frutilla üçì</h5>
                                <p class="lead">$300</p>
                                <button class="btn btn-primary btn-sm" data-fruta="frutilla" data-precio="300">Agregar</button>
                            </div>
                        </div>
                    </article>
                    <article class="col-sm-4 mb-3">
                        <div class="card">
                            <div class="card-body">
                                <h5 class="card-title">Banana üçå</h5>
                                <p class="lead">$100</p>
                                <button class="btn btn-primary btn-sm" data-fruta="banana" data-precio="100">Agregar</button>
                            </div>
                        </div>
                    </article>
                    <article class="col-sm-4 mb-3">
                        <div class="card">
                            <div class="card-body">
                                <h5 class="card-title">Manzana üçè</h5>
                                <p class="lead">$200</p>
                                <button class="btn btn-primary btn-sm" data-fruta="manzana" data-precio="200">Agregar</button>
                            </div>
                        </div>
                    </article>
                </div>
            </main>

            <section class="container mt-3">
                <ul class="list-group" id="carrito"></ul>
            </section>

            <footer id="footer" class="container mt-3">
                <template id="templateFooter">
                    <div class="card">
                        <div class="card-body d-flex justify-content-between align-items-center">
                            <p class="lead mb-0">TOTAL: $<span>1500</span></p>
                            <button class="btn btn-outline-primary">Finalizar Compra</button>
                        </div>
                    </div>
                </template>
            </footer>

            <template id="template">
                <li class="list-group-item text-uppercase bg-secondary text-white">
                    <span class="badge bg-primary rounded-pill align-middle">14</span>
                    <span class="lead align-middle">A list item</span>
                </li>
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <p class="lead mb-0">Total: $<span>200</span></p>
                    </div>
                    <div>
                        <button class="btn btn-sm btn-success">Agregar</button>
                        <button class="btn btn-sm btn-danger">Quitar</button>
                    </div>
                </li>
            </template>

            <script src="app.js"></script>
        </body>

        </html> -->

        const carrito = document.querySelector("#carrito");
        const template = document.querySelector("#template");
        const footer = document.querySelector("#footer");
        const templateFooter = document.querySelector("#templateFooter");
        const fragment = document.createDocumentFragment();
        let carritoArray = [];

        // Delegaci√≥n de eventos:
        document.addEventListener("click", (e) => {
        // console.log(e);
        // console.log(e.target.dataset.fruta);
        // console.log(e.target.matches(".card button"));
        if (e.target.matches(".card button")) {
            agregarCarrito(e);
        }

        // console.log(e.target.matches(".list-group-item .btn-success"));
        if (e.target.matches(".list-group-item .btn-success")) {
            btnAumentar(e);
        }

        // console.log(e.target.matches(".list-group-item .btn-danger"));
        if (e.target.matches(".list-group-item .btn-danger")) {
            btnDisminuir(e);
        }
        });

        const agregarCarrito = (e) => {
        // console.log(e.target.dataset);
        const producto = {
            titulo: e.target.dataset.fruta,
            id: e.target.dataset.fruta,
            cantidad: 1,
            precio: parseInt(e.target.dataset.precio),
        };

        // buscamos el indice
        const index = carritoArray.findIndex((item) => item.id === producto.id);

        // si no existe empujamos el nuevo elemento
        if (index === -1) {
            carritoArray.push(producto);
        } else {
            // en caso contrario aumentamos su cantidad
            carritoArray[index].cantidad++;
        }

        // console.log(carritoArray);
        pintarCarrito();
        };

        const pintarCarrito = () => {
        carrito.textContent = "";

        // recorremos el carrito y pintamos elementos:
        carritoArray.forEach((item) => {
            const clone = template.content.cloneNode(true);
            clone.querySelector(".text-white .lead").textContent = item.titulo;
            clone.querySelector(".rounded-pill").textContent = item.cantidad;
            clone.querySelector("div .lead span").textContent =
                item.precio * item.cantidad;
            clone.querySelector(".btn-success").dataset.id = item.id;
            clone.querySelector(".btn-danger").dataset.id = item.id;
            fragment.appendChild(clone);
        });
        carrito.appendChild(fragment);

        pintarFooter();
        };

        const pintarFooter = () => {
        footer.textContent = "";

        const total = carritoArray.reduce(
            (acc, current) => acc + current.precio * current.cantidad,
            0
        );

        // console.log(total);

        const clone = templateFooter.content.cloneNode(true);
        clone.querySelector("p span").textContent = total;

        // fragment.appendChild(clone);
        footer.appendChild(clone);
        };

        const btnAumentar = (e) => {
        // console.log(e.target.dataset.id);
        carritoArray = carritoArray.map((item) => {
            if (item.id === e.target.dataset.id) {
                item.cantidad++;
            }
            return item;
        });
        pintarCarrito();
        };

        const btnDisminuir = (e) => {
        // console.log(e.target.dataset.id);
        carritoArray = carritoArray.filter((item) => {
            // console.log(item);
            if (item.id === e.target.dataset.id) {
                if (item.cantidad > 0) {
                    item.cantidad--;
                    // console.log(item);
                    if (item.cantidad === 0) return;
                    return item;
                }
            } else {
                return item;
            }
        });
        pintarCarrito();
        };




        Expresiones Regulares

            Regular Expressions

        (opens new window): Las expresiones regulares (a menudo llamadas RegExp o RegEx) son patrones que se utilizan para hacer coincidir combinaciones de caracteres en cadenas.
        Fuente #02

            (opens new window): Son un sistema para buscar, capturar o reemplazar texto utilizando patrones.
            Estos patrones permiten realizar una b√∫squeda de texto de una forma relativamente sencilla y abstracta, de forma que abarca una gran cantidad de posibilidades que de otra forma ser√≠a imposible o muy costosa.
            /patron/flags

        // notaci√≥n literal
        const regExpLiteral = /bluuweb/i

        // notaci√≥n de objeto
        const regExpObjeto = new RegExp("bluuweb", "i")

        #
        Flags de una RegExp

            i Ignora may√∫sculas y min√∫sculas. Se suele denominar insensible a may√∫s/min√∫s.
            g B√∫squeda global. Sigue buscando coincidencias en lugar de pararse al encontrar una.
            m Multil√≠nea. Permite a ^ y $ tratar los finales de l√≠nea \r o \n.

        #
        M√©todos de RegExp

            El m√©todo test() ejecuta la b√∫squeda de una ocurrencia entre una expresi√≥n regular y una cadena especificada. Devuelve true o false.
            Retorna true si existe una coincidencia entre la expresi√≥n regular y la cadena especificada; de lo contrario retorna false.
            Use test()cuando desee saber si existe la ocurrencia de un patr√≥n en una cadena

        console.log(regExpLiteral.test("Bluuweb")); // true
        console.log(regExpLiteral.test("bluweb")); // false

        #
        Car√°cteres especiales

            [ ] Rango de car√°cteres. Cualquiera de los caracteres del interior de los corchetes.
            | Establece una alternativa: lo que est√° a la izquierda o lo que est√° a la derecha.

        const regExpLiteral = /[ue]/gi;

        console.log(regExpLiteral.test("bluuweb"));
        console.log(regExpLiteral.test("ignacio"));

        const regExpLiteral = /bluweb|bluuweb/gi;
        const str = "bluuweb";

        console.log(regExpLiteral.test(str));

            [0-9] Un d√≠gito del 0 al 9.
            [A-Z] Letra may√∫scula de la A a la Z. Excluye √± o letras acentuadas.
            [a-z] Letra min√∫scula de la a a la z. Excluye √± o letras acentuadas.
            [A-Za-z0-9] Car√°cter alfanum√©rico (letra may√∫scula, min√∫scula o d√≠gito).

        const regExpLiteral = /[0-9]/gi;
        const str = "234";

        console.log(regExpLiteral.test(str));

        const regExpLiteral = /[a-z]/gi;
        const str = "bluuweb13";

        console.log(regExpLiteral.test(str));

        Solo n√∫meros:

        const regExpLiteral = /^\d+$/gi;
        const str = "bluuweb123";

        console.log(regExpLiteral.test(str));

        Solo letras (sin tildes):

        const regExpLiteral = /^[a-zA-Z ]*$/;
        const str = "bluuweb";

        console.log(regExpLiteral.test(str));

        Solo letras (con tildes):

        /^[A-Za-z√ë√±√Å√°√â√©√ç√≠√ì√≥√ö√∫√ú√º\s]+$/

        Validar email:

        /^[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})$/


            Validaci√≥n Formularios

            Form validation
        
        (opens new window): Antes de enviar datos al servidor, es importante asegurarse de que se completan todos los controles de formulario requeridos, y en el formato correcto.
        Esto se denomina validaci√≥n de formulario en el lado del cliente y ayuda a garantizar que los datos que se env√≠an coinciden con los requisitos establecidos en los diversos controles de formulario.
        La validaci√≥n en el lado del cliente es una verificaci√≥n inicial y una caracter√≠stica importante para garantizar una buena experiencia de usuario.
        Sin embargo, ¬°la validaci√≥n en el lado del cliente no debe considerarse una medida de seguridad exhaustiva! Tus aplicaciones siempre deben realizar comprobaciones de seguridad de los datos enviados por el formulario en el lado del servidor.
        Website security
        
            (opens new window)
        
        Hay dos tipos diferentes de validaci√≥n por parte del cliente que encontrar√°s en la web:
        
            La validaci√≥n de formularios incorporada utiliza caracter√≠sticas de validaci√≥n de formularios HTML5, Esta validaci√≥n generalmente no requiere mucho JavaScript. La validaci√≥n de formularios incorporada tiene un mejor rendimiento que JavaScript, pero no es tan personalizable como la validaci√≥n con JavaScript.
            La validaci√≥n con JavaScript se codifica utilizando JavaScript. Esta validaci√≥n es completamente personalizable, pero debes crearlo todo (o usar una biblioteca).
        
        #
        HTML5
        
        Esto se realiza mediante el uso de atributos de validaci√≥n en los elementos del formulario.
        
            required:
        
        (opens new window) Especifica si un campo de formulario debe completarse antes de que se pueda enviar el formulario.
        minlength
        (opens new window) y maxlength
        (opens new window): Especifican la longitud m√≠nima y m√°xima de los datos de texto (cadenas).
        min
        (opens new window) y max
        (opens new window): Especifican los valores m√≠nimo y m√°ximo de los tipos de entrada num√©ricos.
        type: Especifica si los datos deben ser un n√∫mero, una direcci√≥n de correo electr√≥nico o alg√∫n otro tipo de preajuste espec√≠fico.
        pattern
        
            (opens new window): Especifica una expresi√≥n regular que define un patr√≥n que los datos que se introduzcan deben seguir.
        
        WARNING
        
        Nota: El elemento <textarea> no admite el atributo pattern.
        
        <!-- <div class="container">
            <h1>Formularios</h1>
        
            <form id="formulario">
                <input
                    class="form-control mb-2"
                    name="userName"
                    placeholder="Ingrese su nombre"
                    autocomplete="off"
                    id="userName"
                    type="text"
                    required
                    pattern="^[A-Za-z√ë√±√Å√°√â√©√ç√≠√ì√≥√ö√∫√ú√º\s]+$"
                    title="Solo letras"
                    minlength="3"
                    maxlength="10"
                />
                <input
                    class="form-control mb-2"
                    name="userEmail"
                    placeholder="Ingrese su correo"
                    id="userEmail"
                    autocomplete="off"
                    type="email"
                    required
                    pattern="^[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})$"
                    title="Ingresa un email v√°lido"
                />
                <button class="btn btn-primary" type="submit">Enviar</button>
            </form>
        </div> -->
        



                Eventos

        Ya aprendimos que podemos capturar eventos a trav√©s de Javascript utilizando addEventListener

        (opens new window), hoy conoceremos algunos para procesar formularios.
        #
        submit

        <!-- <div class="container">
            <h1>Formularios</h1>

            <form id="formulario">
                <input
                class="form-control mb-2"
                placeholder="Ingrese su nombre"
                type="text"
                id="userName"
                name="userName"
                >
                <input
                class="form-control mb-2"
                placeholder="Ingrese su correo"
                type="email"
                id="userEmail"
                name="userEmail"
                >
                <button
                class="btn btn-primary">Enviar</button
                type="submit"
                >
            </form>
        </div> -->

        const formulario = document.getElementById("formulario");

        formulario.addEventListener("submit", (e) => {
            e.preventDefault();
            console.log("funciona");
        });

        #
        Capturar value

        Por id

        const formulario = document.getElementById("formulario");
        const userName = document.getElementById("userName");
        const userEmail = document.getElementById("userEmail");

        formulario.addEventListener("submit", (e) => {
            e.preventDefault();
            console.log("funciona");

            console.log(userName.value);
            console.log(userEmail.value);
        });

        Por querySelector input

        const formulario = document.querySelector("#formulario");
        const userName = document.querySelector("input[name='userName']");
        const userEmail = document.querySelector("input[name='userEmail']");

        formulario.addEventListener("submit", (e) => {
            e.preventDefault();
            console.log("funciona");

            console.log(userName.value);
            console.log(userEmail.value);
        });

        #
        V√°lidar solo con JS

        üëÄ saqu√© las validaciones de HTML5, Tambien se puede colocar novalidate como atributo.

        <!-- <form id="formulario" novalidate>
            <input
                class="form-control mb-2"
                name="userName"
                placeholder="Ingrese su nombre"
                autocomplete="off"
                id="userName"
                type="text"
                value="ignacio"
            />
            <input
                class="form-control mb-2"
                name="userEmail"
                placeholder="Ingrese su correo"
                id="userEmail"
                autocomplete="off"
                type="email"
                value="ignacio@megusta.com" -->
            />
            <!-- <button class="btn btn-primary" type="submit">Enviar</button>
        </form> -->

        const formulario = document.getElementById("formulario");
        const userName = document.getElementById("userName");
        const userEmail = document.getElementById("userEmail");

        formulario.addEventListener("submit", (e) => {
            e.preventDefault();

            const regUserName = /^[A-Za-z√ë√±√Å√°√â√©√ç√≠√ì√≥√ö√∫√ú√º\s]+$/;
            const regUserEmail = /^[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})$/;

            if (!regUserName.test(userName.value)) {
                return console.log("Solo letras");
            }

            if (!regUserEmail.test(userEmail.value)) {
                return console.log("Formato email no v√°lido");
            }

            console.log("Formulario enviado con √©xito");
        });


            <!-- Alertas y colores

        Ejemplo Final

    (opens new window)
    input error Bootstrap

        (opens new window)

    WARNING

    En este ejercicio se puede reducir el c√≥digo (sobretodo utilizando solo Bootstrap 5), pero para fines ilustrativos tratar√© de repasar todo lo aprendido hasta el momento, pero pueden dejar otras soluciones en discord para complementar el ejemplo: click aqu√≠

    (opens new window)

    <!DOCTYPE html>
    <html lang="es">
        <head>
            <meta charset="UTF-8" />
            <meta http-equiv="X-UA-Compatible" content="IE=edge" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Carrito Objeto</title>
            <link
                crossorigin="anonymous"
                href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
                integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
                rel="stylesheet"
            />
        </head>

        <body>
            <div class="container">
                <h1>Formularios</h1>

                <form id="formulario">
                    <input
                        class="form-control mb-2"
                        name="userName"
                        placeholder="Ingrese su nombre"
                        autocomplete="off"
                        id="userName"
                        type="text"
                        value="ignacio"
                    />

                    <p class="text-danger mb-2 d-none" id="alertName"></p>

                    <input
                        class="form-control mb-2"
                        name="userEmail"
                        placeholder="Ingrese su correo"
                        id="userEmail"
                        autocomplete="off"
                        type="email"
                        value="ignacio@megusta.com"
                    />

                    <p class="text-danger mb-2 d-none" id="alertEmail"></p>

                    <button class="btn btn-primary" type="submit">Enviar</button>
                </form>
                <div
                    class="alert alert-success mt-2 d-none"
                    id="alertSuccess"
                ></div>
            </div>

            <script src="app.js"></script>
        </body>
    </html>

    const formulario = document.getElementById("formulario");

    const userName = document.getElementById("userName");
    const userEmail = document.getElementById("userEmail");

    const alertSuccess = document.getElementById("alertSuccess");
    const alertName = document.getElementById("alertName");
    const alertEmail = document.getElementById("alertEmail");

    const regUserName = /^[A-Za-z√ë√±√Å√°√â√©√ç√≠√ì√≥√ö√∫√ú√º\s]+$/;
    const regUserEmail = /^[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})$/;

    const pintarMensajeExito = () => {
        alertSuccess.classList.remove("d-none");
        alertSuccess.textContent = "Mensaje enviado con √©xito";
    };

    const pintarMensajeError = (errores) => {
        errores.forEach((item) => {
            item.tipo.classList.remove("d-none");
            item.tipo.textContent = item.msg;
        });
    };

    formulario.addEventListener("submit", (e) => {
        e.preventDefault();

        alertSuccess.classList.add("d-none");
        const errores = [];

        // validar nombre
        if (!regUserName.test(userName.value) || !userName.value.trim()) {
            userName.classList.add("is-invalid");

            errores.push({
                tipo: alertName,
                msg: "Formato no v√°lido campo nombre, solo letras",
            });
        } else {
            userName.classList.remove("is-invalid");
            userName.classList.add("is-valid");
            alertName.classList.add("d-none");
        }

        // validar email
        if (!regUserEmail.test(userEmail.value) || !userEmail.value.trim()) {
            userEmail.classList.add("is-invalid");

            errores.push({
                tipo: alertEmail,
                msg: "Escriba un correo v√°lido",
            });
        } else {
            userEmail.classList.remove("is-invalid");
            userEmail.classList.add("is-valid");
            alertEmail.classList.add("d-none");
        }

        if (errores.length !== 0) {
            pintarMensajeError(errores);
            return;
        }

        console.log("Formulario enviado con √©xito");
        pintarMensajeExito();
    });

    #
    FormData

        formData

    (opens new window): La interfaz FormData proporciona una manera sencilla de construir un conjunto de parejas clave/valor que representan los campos de un formulario y sus valores, que pueden ser enviados f√°cilmente. Est√°n destinados principalmente para el env√≠o de los datos del formulario, pero se pueden utilizar de forma independiente con el fin de transmitir los datos tecleados.
    API/FormData)

        (opens new window)
        FormData.get() Devuelve el primer valor asociado con una clave dada en un objeto FormData.
        FormData.entries() Devuelve un iterator que permite recorrer todas las parejas clave/valor contenidas en este objeto.
        FormData.values() Devuelve un iterator que permite recorrer todos los valores contenidos en este objeto.

    formulario.addEventListener("submit", (e) => {
        e.preventDefault();
        console.log("funciona");

        const inputs = new FormData(formulario);
        console.log(inputs.get("userName"));
        console.log(inputs.get("userEmail"));

        for (let campo of inputs.values()) {
            console.log(campo);
        }

        for (let campo of inputs.entries()) {
            console.log(campo);
        }
    }); -->


            El objetivo de esta secci√≥n es entender el uso de:

            Callbacks
            Promesas
            Try Catch
            Async Await
            Introducci√≥n a Fetch API
            ¬øQue es una API?

        #
        Callbacks

            Callback

            (opens new window): Una funci√≥n de callback es una funci√≥n que se pasa a otra funci√≥n como un argumento, que luego se invoca dentro de la funci√≥n externa para completar alg√∫n tipo de rutina o acci√≥n.
            Cada vez se ocupan menos.
            Pasar una funci√≥n como argumento.

        const posts = [
            {
                "userId": 1,
                "id": 1,
                "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
                "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
            },
            {
                "userId": 1,
                "id": 2,
                "title": "qui est esse",
                "body": "est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla"
            },
            {
                "userId": 1,
                "id": 3,
                "title": "ea molestias quasi exercitationem repellat qui ipsa sit aut",
                "body": "et iusto sed quo iure\nvoluptatem occaecati omnis eligendi aut ad\nvoluptatem doloribus vel accusantium quis pariatur\nmolestiae porro eius odio et labore et velit aut"
            },
        ];

        const findPostById = (id, callback) => {
            const post = posts.find((item) => item.id === id);

            callback(post);
        };

        findPostById(1, (post) => {
            console.log(post);
        });

        #
        Errores

        const findPostById = (id, callback) => {
            const post = posts.find((item) => item.id === id);

            if (post) {
                // mandamos el null ya que no existen errores
                callback(null, post);
            } else {
                // en caso de que no exista el post
                callback("No encontrado por id: " + id);
            }
        };

        // ser recibe el err como primer argumento
        findPostById(4, (err, post) => {
            if (err) {
                return console.log(err);
            }
            console.log(post);
        });

        #
        Callback Hell
        abrir snippet vscode

        findPostById(1, (err, post) => {
            if (err) {
                return console.log(err);
            }

            findPostById(2, (err, post2) => {
                if (err) {
                    return console.log(err);
                }
                console.log(post.title, post2.title);
            });
        });

            #
            Promesas

                promise

                (opens new window): Una Promise (promesa en castellano) es un objeto que representa la terminaci√≥n o el fracaso de una operaci√≥n as√≠ncrona.

            abrir snippet vscode

            const findPostById = (id) => {
                const post = posts.find((item) => item.id === id);

                // devolver la promesa
                return new Promise((resolve, reject) => {
                    //resolve
                    if (post) {
                        resolve(post);
                    } else {
                        reject("No encontrado por id: " + id);
                    }
                });
            };

            findPostById(1)
                .then((post) => console.log(post))
                .catch((err) => console.log(err))
                .finally(() => console.log("fin de la promesa"));

            Ahorrando teclas:

            const findPostById = (id) =>
                new Promise((resolve, reject) => {
                    const post = posts.find((item) => item.id === id);

                    post ? resolve(post) : reject("No encontrado por id: " + id);
                });

            findPostById(4)
                .then((post) => console.log(post))
                .catch((e) => console.log(e));

            #
            hell

            findPostById(1)
                .then((post) => {
                    console.log(post.title);
                    return findPostById(2);
                })
                .then((post) => {
                    console.log(post.title);
                    return findPostById(3);
                })
                .then((post) => {
                    console.log(post.title);
                    return findPostById(4);
                })
                .then((post) => console.log(post.title))
                .catch((e) => console.log(e));

            #
            async await

                async

            (opens new window): La declaraci√≥n de funci√≥n async define una funci√≥n as√≠ncrona, la cual devuelve una AsyncFunction.
            await

                (opens new window): El operador await es usado para esperar a una Promise. S√≥lo puede ser usado dentro de una funci√≥n async function.

            const findPostById = (id) =>
                new Promise((resolve, reject) => {
                    setTimeout(() => {
                        const post = posts.find((item) => item.id === id);
                        post ? resolve(post) : reject("No encontrado por id: " + id);
                    }, 2000);
                });

            findPostById(1)
                .then((post) => console.log(post))
                .catch((e) => console.log(e));

            console.log("Fin de todo");

            const findPostById = (id) =>
                new Promise((resolve, reject) => {
                    setTimeout(() => {
                        const post = posts.find((item) => item.id === id);
                        post ? resolve(post) : reject("No encontrado por id: " + id);
                    }, 2000);
                });

            const buscar = async () => {
                const post = await findPostById(1);
                console.log(post);
            };

            buscar();

            try catch

            const findPostById = (id) =>
                new Promise((resolve, reject) => {
                    setTimeout(() => {
                        const post = posts.find((item) => item.id === id);
                        post ? resolve(post) : reject("No encontrado por id: " + id);
                    }, 2000);
                });

            const buscar = async () => {
                try {
                    const post = await findPostById(4);
                    console.log(post);
                } catch (error) {
                    console.log(error);
                }
            };

            buscar();

            M√∫ltiples solicitudes:

            const buscar = async () => {
                try {
                    const postUno = await findPostById(1);
                    const postDos = await findPostById(2);

                    // se est√° demorando 4 segundos ??
                    console.log(postUno.title, postDos.title);
                } catch (error) {
                    console.log(error);
                }
            };

            buscar();

            #
            Promise.all

            const buscar = async () => {
                try {
                    // solo en el caso que no dependan una de la otra
                    const rePosts = await Promise.all([findPostById(1), findPostById(2)]);

                    // console.log(rePosts);
                    console.log(rePosts[0].title, rePosts[1].title);
                } catch (error) {
                    console.log(error);
                }
            };

            buscar();

            fetch API

            TIP
            
            Hoy solo veremos una introducci√≥n para entender el uso de las promesas, async y await.
            
                fetch
            
            (opens new window): La API Fetch proporciona una interfaz para recuperar recursos (incluso a trav√©s de la red). Resultar√° familiar a cualquiera que haya usado XMLHttpRequest, pero la nueva API ofrece un conjunto de caracter√≠sticas m√°s potente y flexible.
            El m√©todo fetch() toma un argumento obligatorio, la ruta de acceso al recurso que desea recuperar.
            Devuelve una Promise que resuelve en Response a esa petici√≥n, sea o no correcta.
            Una vez que Response es recuperada, hay varios m√©todos disponibles para definir cu√°l es el contenido del cuerpo y como se debe manejar.
            jsonplaceholder
            (opens new window)
            post 1
            
                (opens new window)
            
            fetch("https://jsonplaceholder.typicode.com/posts/1")
                .then((res) => console.log(res));
            
            fetch("https://jsonplaceholder.typicode.com/posts/1")
                .then((res) => res.json())
                .then((data) => console.log(data));
            
            const findPostById = async (id) => {
                try {
                    const res = await fetch("https://jsonplaceholder.typicode.com/posts/1");
                    const post = await res.json();
                    console.log(post);
                } catch (error) {
                    console.log(error);
                }
            };
            
            findPostById(1);
            
            const findPostById = async (id) => {
                try {
                    const res = await fetch(
                        "https://jsonplaceholder.typicode.com/posts/" + id
                    );
                    const post = await res.json();
                    console.log(post);
                } catch (error) {
                    console.log(error);
                }
            };
            
            findPostById(50);
            
            #
            ¬øQu√© son las APIs?
            
                api
            
                (opens new window): Interfaces de Programacion de Aplicaciones (APIs por sus siglas en ingl√©s)
            
            API son construcciones disponibles en los lenguajes de programaci√≥n que permiten a los desarrolladores crear funcionalidades complejas de una manera simple. Estas abstraen el c√≥digo m√°s complejo para proveer una sintaxis m√°s f√°cil de usar en su lugar.
            
            Si quisieras programar gr√°ficos 3D, ser√≠a mucho m√°s facil hacerlo usando una API escrita en un lenguaje de alto nivel como JavaScript o Python, en lugar de intentar escribir c√≥digo de bajo nivel (por ejemplo: C o C++) que controle directamente la GPU del equipo u otras funciones gr√°ficas.
            #
            APIs en JavaScript del lado cliente
            
            JavaScript del lado cliente, particularmente, tiene muchas APIs disponibles ‚Äî estas no son parte del lenguaje en s√≠, sino que est√°n construidas sobre el n√∫cleo de este lenguaje de programaci√≥n, proporcion√°ndote superpoderes adicionales para usar en tu c√≥digo. Por lo general, se dividen en dos categor√≠as:
            
                Las APIs de navegador: est√°n integradas en tu navegador web, Por ejemplo, la API de Geolocalizaci√≥n proporciona algunas construcciones simples de JavaScript para obtener datos de ubicaci√≥n con los que, por ejemplo, trazar tu ubicaci√≥n en un mapa de Google. Realmente, el navegador est√° haciendo uso de c√≥digos de bajo nivel complejos en segundo plano (por ejemplo, C++) para comunicarse con el hardware GPS del dispositivo (o lo que est√© disponible para determinar los datos de posici√≥n), recuperar datos de posici√≥n y devolverlos al entorno del navegador para su uso en tu c√≥digo. Pero una vez m√°s, la API se encarga de abstraer esta complejidad.
                Las APIs de terceros: no est√°n inclu√≠das por defecto en el navegador, y por lo general es necesario obtener el c√≥digo e informaci√≥n desde alg√∫n lugar de la Web. Por ejemplo, la API de Twitter permite hacer cosas como mostrar tus √∫ltimos tweets en un sitio web.
            
            #
            APIs de navegador m√°s comunes
            
                APIs para manipular documentos cargados en el navegador. El ejemplo m√°s obvio es la API DOM
                APIs que obtienen datos del servidor, comunmente usadas para actualizar peque√±as secciones de una p√°gina web. Fetch API
            
                (opens new window).
                Las APIs para dibujar y manipular graficos: Las m√°s populares son Canvas y WebGL
                APIS de audio y v√≠deo como HTMLMediaElement, la Web Audio API, y WebRTC
                Las APIs de dispositivos: geolocalizaci√≥n, notificaciones de sistema, vibraci√≥n de hardware, etc
                Las APIS de almacenamiento en el lado del cliente: Web Storage API (sessionStorage, localStorage), IndexedDB API.
            
            #
            APIs populares de terceros
            
                Google maps
                Facebook, Twitter, Instagram, Discord, Youtube, etc
                jsonplaceholder
            
            #
            ¬øQue es API REST?
            
            REST: "Representational State Transfer" o traducido a "Transferencia de presentaci√≥n de estado".
            
            Cuando queremos comunicar nuestro mundo del Frontend con el Backend (por ejemplo con Node.js), necesitamos alguna t√©cnica. Aqu√≠ es donde nosotros podemos construir nuestra propia API para que nuestras aplicaciones se comuniquen de manera efectiva.
            
            Para que la comunicaci√≥n no sea un despelote existe el t√©rmino de REST, que es un estandar para la construcci√≥n de APIS. una t√©cnica de arquitectura de software usada para construir APIs que permitan comunicar a nuestro servidor con sus clientes usando el protocolo HTTP mediante URIs lo suficientemente inteligentes para poder satisfacer la necesidad del cliente.
            
            Por ende API REST en simples palabras ser√≠a: Una forma de entregar recursos para su utilizaci√≥n (comunicaci√≥n) estandarizado y basado en arquitectura REST.
            
            Para que sea REST:
            
                REST es STATELESS: TOKEN para cada petici√≥n realizada a la API.
                Crea URIs √∫nicas que permiten al cliente entender y utilizar lo que est√° exponiendo. api.anexsoft.com/users
                Tiene que responder a verbos Http: GET, POST, PUT, DELETE
            
            #
            ¬øQu√© es Restful?
            
            REST es el concepto, RESTFul es la implementaci√≥n y al crear un RESTFul creamos una API, la cual una API es un conjunto de funciones o procedimientos para que sea utilizado por otro software.



                fetch: La API Fetch proporciona una interfaz para recuperar recursos.
        Fetch es una interfaz para hacer solicitudes AJAX en JavaScript. Es usado generalmente para hacer una solicitud a un API.
        El m√©todo fetch() toma un argumento obligatorio, la ruta de acceso al recurso que desea recuperar.
        fuente #02

            (opens new window)

        #
        Ajax

            ajax

            (opens new window)
            JavaScript As√≠ncrono + XML (XML viejito ahora utilizamos JSON)
            AJAX no es una tecnolog√≠a por s√≠ misma, es un t√©rmino que describe un nuevo modo de utilizar conjuntamente varias tecnolog√≠as existentes.
            Esto incluye: HTML, CSS, JavaScript, DOM, JSON y lo m√°s importante, el objeto XMLHttpRequest (XMLHttpRequest viejito ahora Fetch)
            Cuando estas tecnolog√≠as se combinan en un modelo AJAX, es posible lograr aplicaciones web capaces de actualizarse continuamente sin tener que volver a cargar la p√°gina completa.
            Esto crea aplicaciones m√°s r√°pidas y con mejor respuesta a las acciones del usuario.

        #
        M√©todos nativos para AJAX

            XMLHttpRequest

        (opens new window)
        fetch API

            (opens new window)

        #
        Fetch API

            Fetch api

        (opens new window) Proporciona una interfaz JavaScript para hacer peticiones HTTP as√≠ como sus respuestas.
        Tambi√©n provee un m√©todo para obtener recursos de forma as√≠ncrona por la red.
        fetch par√°metros

            (opens new window) inicia el proceso de obtener un recurso de la red, devolviendo una promesa que se cumple una vez que la respuesta est√° disponible.
            Este tipo de funcionalidad se consegu√≠a previamente haciendo uso de XMLHttpRequest.

        fetch('http://example.com/movies.json')
        .then(response => response.json())
        .then(data => console.log(data));

        Conceptos Claves al momento de hacer una petici√≥n HTTP:

            HTTP:

        (opens new window) Hypertext Transfer Protocol (HTTP) (o Protocolo de Transferencia de Hipertexto en espa√±ol) es el nombre de un protocolo el cual nos permite realizar una petici√≥n de datos y recurso.
        Ruta (PATH): Es la direcci√≥n de donde queremos obtener los recursos.
        M√©todos Http:
        (opens new window) HTTP define un conjunto de m√©todos de petici√≥n para indicar la acci√≥n que se desea realizar para un recurso determinado. (GET, POST, PUT, PATCH, DELETE)
        Cabeceras (headers): Cabeceras HTTP opcionales, que pueden aportar informaci√≥n adicional a los servidores.
        C√≥digos de respuestas (Response Codes): Un c√≥digo de estado, indicando si la petici√≥n ha sido exitosa, o no, y debido a que. m√°s info
        (opens new window) cat http
        (opens new window)
        JSON:

            (opens new window) JavaScript Object Notation, es un formato basado en texto est√°ndar para representar datos estructurados en la sintaxis de objetos de JavaScript. Es com√∫nmente utilizado para transmitir datos en aplicaciones web.

        #
        Estructura del JSON

            Como se describi√≥ previamente, un JSON es una cadena cuyo formato recuerda al de los objetos literales JavaScript.
            Es posible incluir los mismos tipos de datos b√°sicos dentro de un JSON que en un objeto est√°ndar de JavaScript - cadenas, n√∫meros, arreglos, booleanos, y otros literales de objeto.
            Esto permite construir una jerarqu√≠a de datos, como √©sta: pokeapi/ditto

        (opens new window)
        Json Formatter Chrome

            (opens new window)

        #
        Volviendo a Fetch

        const url = "https://pokeapi.co/api/v2/pokemon/";

        fetch(url)
            .then((res) => res.json())
            .then((data) => console.log(data));

            Aqu√≠ estamos recuperando un archivo JSON a trav√©s de red e imprimiendo en la consola.
            El uso de fetch() m√°s simple toma un argumento (la ruta del recurso que quieres obtener) y devuelve un objeto Promise conteniendo la respuesta, un objeto Response.
            Esto es, por supuesto, una respuesta HTTP sin el archivo JSON.
            Para extraer el contenido en el cuerpo del JSON desde la respuesta, usamos el m√©todo json(), el cual est√° implementado por los objetos Request y Response.

        #
        En profundidad

            fetch

            (opens new window)

        fetch(resource [, init])

            resource: Esto define el recurso que desea recuperar.
            init (opcional): Un objeto que contiene cualquier configuraci√≥n personalizada que desee aplicar a la solicitud. Las posibles opciones son:
                method: El m√©todo de la petici√≥n, por ejemplo, GET, POST. Tenga en cuenta que el Originencabezado no se establece en las solicitudes Fetch con un m√©todo de HEADo GET.
                headers: Cualquier encabezado que desee agregar a su solicitud, contenido dentro de un Headersobjeto o un objeto literal con String valores.
                body: Cualquier cuerpo que desea agregar a su solicitud: esto puede ser una Blob, BufferSource, FormData, URLSearchParams, USVString, o ReadableStreamobjeto. Tenga en cuenta que una solicitud que utiliza el m√©todo GET no puede tener un cuerpo.
                mode: El modo en el que desea utilizar para la solicitud, por ejemplo, cors, no-cors, o same-origin.
                credentials: Controla lo que hacen los navegadores con las credenciales.

        Ejemplo m√©todo POST

        (opens new window)

        // Ejemplo implementando el metodo POST:
        async function postData(url = '', data = {}) {
        // Opciones por defecto estan marcadas con un *
        const response = await fetch(url, {
            method: 'POST', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            headers: {
            'Content-Type': 'application/json'
            // 'Content-Type': 'application/x-www-form-urlencoded',
            },
            redirect: 'follow', // manual, *follow, error
            referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
            body: JSON.stringify(data) // body data type must match "Content-Type" header
        });
        return response.json(); // parses JSON response into native JavaScript objects
        }

        postData('https://example.com/answer', { answer: 42 })
        .then(data => {
            console.log(data); // JSON data parsed by `data.json()` call
        });

        #
        Ejercicio pokeApi

            rickandmortyapi

        (opens new window)
        get character
        (opens new window)
        Ejemplo Final
        (opens new window)
        PokeApi tutorial

            (opens new window)

        <!-- <!DOCTYPE html>
        <html lang="en">
            <head>
                <!-- Required meta tags -->
                <!-- <meta charset="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />

                <!-- Bootstrap CSS -->
                <!-- <link
                    href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
                    rel="stylesheet"
                    <!-- integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
                    crossorigin="anonymous"
                />

                <title>Poke API</title>
            </head>
            <body>
                <div class="container my-5">
                    <section class="d-flex align-items-center" id="loading">
                        <strong>Loading...</strong>
                        <div
                            class="spinner-border ms-auto"
                            role="status"
                            aria-hidden="true"
                        ></div>
                    </section> --> -->
                    <!-- <div class="row" id="card-dinamica">
                        <template id="template-card">
                            <article class="col-md-6 col-lg-3 mb-3">
                                <div class="card text-center shadow">
                                    <img
                                        src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png"
                                        alt=""
                                        class="card-img-top"
                                    />
                                    <div class="card-body">
                                        <h5 class="card-title text-primary lead">
                                            Rick Sanchez
                                        </h5>
                                        <p class="lead text-secondary">Human</p> -->
                                    <!-- </div>
                                </div>
                            </article>
                        </template>
                    </div>
                </div>

                <script src="app.js"></script>
            </body>
        </html> --> --> -->

        document.addEventListener("DOMContentLoaded", () => {
            fetchData();
        });

        const cards = document.querySelector("#card-dinamica");
        const templateCard = document.querySelector("#template-card").content;

        const fetchData = async () => {
            try {
                loadingData(true);

                const res = await fetch("https://rickandmortyapi.com/api/character");
                const data = await res.json();

                pintarDatos(data);
            } catch (error) {
                console.log(error);
            } finally {
                loadingData(false);
            }
        };

        const loadingData = (estado) => {
            const loading = document.querySelector("#loading");
            if (estado) {
                loading.classList.remove("d-none");
            } else {
                loading.classList.add("d-none");
            }
        };

        const pintarDatos = (data) => {
            const fragment = document.createDocumentFragment();

            cards.textContent = "";

            data.results.forEach((item) => {
                const clone = templateCard.cloneNode(true);
                clone.querySelector("h5").textContent = item.name;
                clone.querySelector("p").textContent = item.species;
                clone.querySelector("img").setAttribute("src", item.image);

                fragment.appendChild(clone);
            });
            cards.appendChild(fragment);
        };



        JS POO :


                La programaci√≥n orientada a objetos es un paradigma de la programaci√≥n en el que se crean objetos para la manipulac√≥n de datos y donde, por lo general, cada objeto ofrece una funcionalidad especial.

            JavaScript no es un lenguaje orientado a objetos basado en clases. Pero tiene formas de usar la programaci√≥n orientada a objetos (POO).
            JavaScript es un lenguaje basado en prototipos.

        #
        ¬øQue es POO?

            POO en JS

            (opens new window)
            Es un paradigma de la programaci√≥n en el que se crean objetos para la manipulac√≥n de datos y donde, por lo general, cada objeto ofrece una funcionalidad especial.
            La idea b√°sica de la POO es que usamos objetos para modelar cosas del mundo real.
            POO nos ayuda a la reutilizaci√≥n del c√≥digo.

        #
        Ejemplo Te√≥rico

            Vamos a considerar un sencillo programa que muestra informaci√≥n sobre estudiantes y profesores en una escuela.
            Aqu√≠ daremos un vistazo a la POO (Programaci√≥n Orientada a Objetos) en general, no en el contexto de alg√∫n lenguaje de programaci√≥n espec√≠fico.

        TIP

        Imagina que tienes un colegio o escuela con 1000 estudiantes y 100 profesores, ser√≠a il√≥gico estar construyendo objetos literales para cada uno de ellos:

        const estudiantoUno = {
            nombre: 'Juanito',
            uid: "e-0001",
            intereses: ["M√∫sica", "F√∫tbol"],
            saludar(){
                return `${this.nombre} dice hola!`
            }
        }

        #
        Paso 1 (Plantilla o Clase):

        Objeto "Persona": (que define los datos generales y funcionalidades de una persona)

            datos generales (propiedades): nombre, edad, g√©nero e intereses
            funcionalidades (m√©todos): que sea capaz de saludar.

        Esto es conocido como abstracci√≥n ‚Äî crear un modelo simple de algo complejo que represente sus aspectos m√°s importantes y que sea f√°cil de manipular para el prop√≥sito de nuestro programa.
        abrir snippet vscode

        TIP

            En algunos lenguajes de POO, esta definici√≥n de tipo de objeto se la llama class (JavaScript utiliza diferentes mecanismos y terminolog√≠as, como ver√°s a continuaci√≥n)
            Esto no es en realidad un objeto, es un modelo (o plantilla) que define las caracter√≠sticas que un objeto deber√≠a tener.

        #
        Paso 2 (Creando objetos)

        Partiendo de nuestra clase, podemos crear instancias de objetos ‚Äî objetos que contienen los datos y funcionalidades definidas en la clase original. Teniendo a nuestra clase Persona, ahora podemos crear gente con caracter√≠sticas m√°s espec√≠ficas:
        abrir snippet vscode

        TIP

            Cuando una instancia del objeto es creada a partir de una clase, se ejecuta la funci√≥n constructora.
            El proceso de crear una instancia del objeto desde una clase se llama instanciaci√≥n.

        #
        Paso 3 (Clases especializadas - Heredar)

            En este caso nosotros no queremos personas gen√©ricas ‚Äî queremos docentes y estudiantes, que son los dos tipos m√°s espec√≠ficos de personas.
            En POO, podemos crear nuevas clases basadas en otras clases, estas nuevas clases secundarias se pueden hacer para heredar los datos y c√≥digo de su clase primaria, de modo que pueden reutilizar la funcionalidad com√∫n a todos los tipos de objetos en lugar de tener que duplicarla.
            Cuando la funcionalidad difiere entre clases, puedes definir funciones especializadas directamente en ellas seg√∫n sea necesario.

        abrir snippet vscode

        Ejemplo de instancia de varios Profesores o docentes a partir de su clase:
        abrir snippet vscode

        #
        ¬øc√≥mo se implementa en JS?

            JavaScript, utiliza funciones especiales llamadas funciones constructoras para definir objetos y sus caracter√≠sticas.
            Los constructores proporcionan los medios para crear tantos objetos como necesites de una manera efectiva, adjuntando datos y funciones a ellos seg√∫n sea necesario.
            Cuando se crea una nueva instancia del objeto a partir de una funci√≥n constructora, su funcionalidad central no se copia en el nuevo objeto como lenguajes OO "cl√°sicos", sino que la funcionalidad est√° vinculada a trav√©s de una cadena de referencia llamada cadena de prototipos.
            As√≠ que esto no es una verdadera instanciaci√≥n, estrictamente hablando, JavaScript usa un mecanismo diferente para compartir funcionalidad entre objetos.

        TIP

        No ser "POO cl√°sica" no es necesariamente algo malo; la POO puede ser muy compleja r√°pidamente, y JavaScript tiene algunas agradables formas de aprovechar las caracter√≠sticas de la OO sin tener que profundizar demasiado en ello.
        #
        Funciones constructoras

        function Persona(nombre) {
            this.nombre = nombre;
            this.saludar = function() {
                return `${this.nombre} dice hola!`;
            };
        }

        const personaUno = new Persona("Ignacio");
        const personaDos = new Persona("Nacho");

        console.log(personaUno); // devuelve un objeto üò≤
        console.log(personaDos); // devuelve un objeto üò≤

        console.log(personaUno.nombre);
        console.log(personaUno.saludar());

            La funci√≥n constructora es la versi√≥n de JavaScript de una clase.
            M√°s adelante veremos que si se puede utilizar class
            Tiene todas las caracter√≠sticas que esperas en una funci√≥n, aunque no devuelve nada.
            B√°sicamente s√≥lo define propiedades y m√©todos.
            this es b√°sicamente decir que cuando se crea una de estas instancias de objeto, la propiedad "nombre" del objeto ser√° igual al valor del nombre pasado a la llamada del constructor, y el m√©todo saludar() usar√° tambi√©n el valor del nombre pasado a la llamada del constructor.
            new se usa para indicarle al navegador que queremos crear una nueva instancia del objeto, seguida del nombre de la funci√≥n con sus par√°metros requeridos entre par√©ntesis, y el resultado se almacena en una variable.

        TIP

        Un nombre de funci√≥n constructora generalmente comienza con una letra may√∫scula ‚Äî esta convenci√≥n se utiliza para hacer que las funciones constructoras sean m√°s f√°ciles de reconocer en el c√≥digo.

        Otra forma de crear instancias de objetos

            Puedes usar el constructor Object()para crear un nuevo objeto.
            Esta es otra forma de crear instancias de objetos.

        const personaUno = new Object();
        personaUno.nombre = "Ignacio";
        personaUno.saludar = function() {
            return `${this.nombre} dice hola!`;
        };

        console.log(personaUno);
        console.log(personaUno.nombre);
        console.log(personaUno.saludar());

        #
        Prototipos de objetos

            Object prototypes

            (opens new window): Los prototipos son un mecanismo mediante el cual los objetos en JavaScript heredan caracter√≠sticas entre s√≠.
            En este art√≠culo, explicaremos como funcionan los prototipos y tambi√©n c√≥mo se pueden usar las propiedades de estos para a√±adir m√©todos a los contructores existentes.

        #
        ¬øUn lenguaje basado en prototipos?

            JavaScript es a menudo descrito como un lenguaje basado en prototipos - para proporcionar mecanismos de herencia, los objetos pueden tener un objeto prototipo, el cual act√∫a como un objeto plantilla que hereda m√©todos y propiedades.
            Un objeto prototipo del objeto puede tener a su vez otro objeto prototipo, el cual hereda m√©todos y propiedades, y as√≠ sucesivamente. Esto es conocido con frecuencia como la cadena de prototipos, y explica por qu√© objetos diferentes pueden tener disponibles propiedades y m√©todos definidos en otros objetos.
            Para ser exactos, los m√©todos y propiedades son definidos en la propiedad prototype, que reside en la funci√≥n constructora del objeto, no en la instancia misma del objeto.
            En JavaScript, se establece un enlace entre la instancia del objeto y su prototipo (su propiedad __proto__, la cual es derivada de la propiedad prototype sobre el constructor), y las propiedades y metodos son encontrados recorriendo la cadena de prototipos.

        #
        Entendiendo objectos prototipos

        function Persona(nombre) {
            this.nombre = nombre;
            this.saludar = function() {
                return `${this.nombre} dice hola!`;
            };
        }

        const personaUno = new Persona("Ignacio");

        abrir snippet vscode

            En esta lista, podra ver los miembros definidos en el objeto prototipo de personaUno, que es la Persona()
            (Persona() es el constructor) - nombre, saludar.
            Sin embargo, tambi√©n ver√° algunos otros miembros - watch, valueOf, etc
            Que est√°n definidos en el objeto prototipo de Persona(), que es un Objeto (Object).
            Esto demuestra que el prototipo cadena funciona.

        abrir snippet vscode

        Intenta hacer lo mismo con un array:
        abrir snippet vscode

        TIP

        Reiteremos que los m√©todos y propiedades no se copian de un objeto a otro en la cadena del prototipo. Ellos son accedidos subiendo por la cadena como se ha descrito anteriormente.
        #
        Modificando prototipos

        Supongamos que nuestro contructor es el siguiente:

        function Persona(nombre) {
            this.nombre = nombre;

            this.saludar = function() {
                return `${this.nombre} dice hola!`;
            };

            this.saludarIngles = function() {
                return `${this.nombre} says hi!`;
            };
        }

        const personaUno = new Persona("Ignacio");
        console.log(personaUno.saludarIngles());

        abrir snippet vscode

            saludarIngles quiz√°s no es una habilidad de todos las personas, por ende, no ser√≠a optimo estar instanciando cada persona con un m√©todo que quiz√°s nunca utilizaremos.
            Para uno o dos objetos no es un problema, pero ¬øsi fueran 1000 objetos?
            En estos casos podemos crear un prototipo para Persona:

        function Persona(nombre) {
            this.nombre = nombre;

            this.saludar = function() {
                return `${this.nombre} dice hola!`;
            };
        }

        Persona.prototype.saludarIngles = function() {
            return `${this.nombre} says hi!`;
        };

        const personaUno = new Persona("Ignacio");
        console.log(personaUno.saludarIngles());

            En este ejemplo personaUno est√° heredando un prototipo, lo cual no significa que se copia, sino que al momento de llamarlo, JS busca entre los prototipos y de existir lo llama. (recuerda el ejemplo del array, nosotros no definimos los m√©todos push, slice, etc... sino que al momento de llamarlos estos son buscados en la cadena de prototipos)
            Esto es realmente √∫til, pero lo que es m√°s √∫til es que toda la cadena de herencia se ha actualizado din√°micamente.
            Autom√°ticamente hace que este nuevo m√©todo est√© disponible en todas las instancias del objeto creadas desde el constructor.

        TIP

        Raramente ver√°s propiedades definidas en la propiedad prototype, no son muy flexibles cuando son definidas de esta forma.
        #
        class

            class

            (opens new window)
            Las clases de javascript, introducidas en ECMAScript 2015, son una mejora sint√°ctica sobre la herencia basada en prototipos de JavaScript.
            La sintaxis de las clases no introduce un nuevo modelo de herencia orientada a objetos en JavaScript.
            Las clases de JavaScript proveen una sintaxis mucho m√°s clara y simple para crear objetos y lidiar con la herencia.

        class Persona {
            constructor(nombre) {
                this.nombre = nombre;
                // Alunos prefieren est√° convenci√≥n
                // para que no choque con los getter
                // o para definir una propiedad privada (no queda privada)
                // this._nombre = nombre 
            }

            // M√©todo pero se crea un prototype
            saludar = function() {
                return `${this.nombre} dice hola!`;
            };
        }

        // Revisa esto y ver√°s que est√°n al mismo nivel que los m√©todos:
        Persona.prototype.saludarIngles = function() {
            return `${this.nombre} says hi!`;
        };

        const personaUno = new Persona("Ignacio");

        console.log(personaUno.saludarIngles());

        #
        get y setter

            edteam

            (opens new window): El encapsulamiento simplemente encapsula las propiedades de un objeto para que no sean accesibles de manera publica y si deseas acceder a ellos externamente tendr√°s que usar metodos get y set (los cuales se definen con anterioridad)
            Los get no reciben par√°metros.
            Los set pueden recibir solo un par√°metro.
            Los set y get se llaman sin los par√©ntesis ()

        Esto no ser√≠a una buena pr√°ctica:

        const personaUno = new Persona("Ignacio");

        personaUno.nombre = "Juanito";
        console.log(personaUno.nombre);

        class Persona {
            constructor(nombre, libros) {
                this.nombre = nombre;
                this.libros = libros || [];
            }

            // setter
            set setLibro(libro) {
                this.libros.push(libro);
            }

            // getter
            get getLibros() {
                return this.libros;
            }

            // m√©todo
            buscarLibroPorTitulo(titulo) {
                return this.libros.find((item) => item.titulo === titulo);
            }
        }

        const personaUno = new Persona("Ignacio");
        personaUno.setLibro = { titulo: "Papelucho", autor: "Marcela Paz" };
        personaUno.setLibro = {
            titulo: "El principito",
            autor: "Antoine de Saint-Exup√©ry",
        };

        console.log(personaUno.buscarLibroPorTitulo("Papelucho"));

        console.log(personaUno.getLibros);

        #
        Static

            static

            (opens new window) La palabra clave static define un m√©todo est√°tico para una clase.
            Los m√©todos est√°ticos son llamados sin instanciar su clase y no pueden ser llamados mediante una instancia de clase.
            Los m√©todos est√°ticos son a menudo usados para crear funciones de utilidad para una aplicaci√≥n.

        class Persona {

            static probarSaludo(nombre) {
                return `${nombre} est√° saludando`;
            }
        }

        console.log(Persona.probarSaludo("juanito"));

                Heredar

            extends

            (opens new window): La palabra clave extends es usada en declaraciones de clase o expresiones de clase para crear una clase hija.

        class Persona {
            constructor(nombre, edad) {
                this.nombre = nombre;
                this.edad = edad;
            }

            saludar() {
                return `${this.nombre} est√° saludando`;
            }

            static probarSaludo(nombre) {
                return `${nombre} est√° saludando`;
            }
        }


        class Estudiante extends Persona {

        }
        const juanito = new Estudiante("juanito", 55);
        console.log(juanito);

        Si un m√©todo tiene el mismo nombre se sobrescribe: (Polimorfismo)

        class Estudiante extends Persona {
            saludar() {
                return `${this.nombre} es un estudiante saludando`;
            }
        }
        const juanito = new Estudiante("juanito", 55);
        console.log(juanito.saludar());



                Super

            super

            (opens new window)

        class Estudiante extends Persona {
            constructor(nombre, edad, notas = []) {
                super(nombre, edad);
                this.notas = notas;
            }

            set setNotas(nota) {
                this.notas.push(nota);
            }

            get getNotas() {
                return this.notas;
            }

            saludar() {
                return `${this.nombre} es un estudiante saludando`;
            }
        }

        const juanito = new Estudiante("juanito", 55);

        juanito.setNotas = 3;
        juanito.setNotas = 5;
        juanito.setNotas = 7;

        console.log(juanito.getNotas);

        Tambi√©n se puede llamar a un m√©todo de Persona:

        saludarPersona() {
            return super.saludar();
        }

        #
        Private class fields

            Private class fields

        (opens new window)
        Las propiedades de la clase son p√∫blicas de forma predeterminada y se pueden examinar o modificar fuera de la clase.
        Sin embargo, existe una propuesta experimental para permitir la definici√≥n de campos de clase privados utilizando un #prefijo hash .
        caniuse.com

            (opens new window)

        class Estudiante extends Persona {
            #notas = [];

            set setNotas(nota) {
                this.#notas.push(nota);
            }

            get getNotas() {
                return this.#notas;
            }
        }

        const juanito = new Estudiante("juanito", 55);

        // Error: Private field '#notas'
        console.log(juanito.#notas);

        juanito.setNotas = 3;
        juanito.setNotas = 5;
        juanito.setNotas = 7;

        console.log(juanito.getNotas);


                MegaPractica Class

            Ejemplo Final

            (opens new window)

        <!DOCTYPE html>
        <html lang="es">
            <head>
                <!-- Required meta tags -->
                <meta charset="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />

                <!-- Bootstrap CSS -->
                <link
                    href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
                    rel="stylesheet"
                    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
                    crossorigin="anonymous"
                />

                <title>Hello, world!</title>
            </head>
            <body>
                <div class="container my-5">
                    <h1>Estudiantes y Profesores</h1>

                    <!-- alerta en caso de falla -->
                    <div class="alert alert-danger my-2 d-none" role="alert">
                        Todos los campos son obligatorios
                    </div>

                    <form id="formulario">
                        <input
                            class="form-control mb-2"
                            name="nombre"
                            placeholder="Ingrese nombre"
                            type="text"
                            value="Juanito"
                            required
                        />
                        <input
                            class="form-control mb-2"
                            name="edad"
                            placeholder="Ingrese nombre"
                            type="number"
                            value="25"
                            required
                        />

                        <select class="form-select mb-2" name="opcion">
                            <option value="Estudiante" selected>Estudiante</option>
                            <option value="Profesor">Profesor</option>
                        </select>

                        <button class="btn btn-primary" type="submit">Agregar</button>
                    </form>

                    <section class="row mt-3">
                        <div class="col-6" id="cardsEstudiantes"></div>
                        <div class="col-6" id="cardsProfesores"></div>
                    </section>
                </div>

                <template id="templateEstudiante">
                    <article class="card mb-2">
                        <div class="card-body">
                            <h5>
                                <span class="text-primary">Nombre</span>
                                <span class="badge bg-success">Aprobado</span>
                            </h5>
                            <h6></h6>
                            <p class="lead">edad</p>
                            <button class="btn btn-success">Aprobar</button>
                            <button class="btn btn-danger">Reprobar</button>
                        </div>
                    </article>
                </template>

                <template id="templateProfesor">
                    <article class="card mb-2 bg-dark text-white">
                        <div class="card-body">
                            <h5>nombre</h5>
                            <h6></h6>
                            <p class="lead">Edad</p>
                        </div>
                    </article>
                </template>

                <script src="app.js"></script>
            </body>
        </html>

        const formulario = document.querySelector("#formulario");
        const cardsEstudiantes = document.querySelector("#cardsEstudiantes");
        const cardsProfesores = document.querySelector("#cardsProfesores");
        const templateEstudiante = document.querySelector(
            "#templateEstudiante"
        ).content;
        const templateProfesor = document.querySelector("#templateProfesor").content;
        const alert = document.querySelector(".alert");

        const estudiantes = [];
        const profesores = [];

        document.addEventListener("click", (e) => {
            // preguntamos por uid
            if (e.target.dataset.uid) {
                if (e.target.matches(".btn-success")) {
                    estudiantes.map((item) => {
                        // modificamos en caso de que sea true
                        if (item.uid === e.target.dataset.uid) {
                            item.setEstado = true;
                        }
                        // console.log(item);
                        return item;
                    });
                }
                if (e.target.matches(".btn-danger")) {
                    estudiantes.map((item) => {
                        if (item.uid === e.target.dataset.uid) {
                            item.setEstado = false;
                        }
                        console.log(item);
                        return item;
                    });
                }
                Persona.pintarPersonaUI(estudiantes, "Estudiante");
            }
        });

        class Persona {
            constructor(nombre, edad) {
                this.nombre = nombre;
                this.edad = edad;
                // agregamos uid
                this.uid = `${Date.now()}`;
            }

            static pintarPersonaUI(personas, tipo) {
                if (tipo === "Estudiante") {
                    cardsEstudiantes.textContent = "";
                    const fragment = document.createDocumentFragment();

                    personas.forEach((item) => {
                        fragment.appendChild(item.agregarNuevoEstudiante());
                    });

                    cardsEstudiantes.appendChild(fragment);
                }

                if (tipo === "Profesor") {
                    cardsProfesores.textContent = "";
                    const fragment = document.createDocumentFragment();
                    personas.forEach((item) => {
                        fragment.appendChild(item.agregarNuevoProfesor());
                    });
                    cardsProfesores.appendChild(fragment);
                }
            }
        }

        class Estudiante extends Persona {
            #estado = false;
            #estudiante = "Estudiante";

            set setEstado(estado) {
                this.#estado = estado;
            }

            get getEstudiante() {
                return this.#estudiante;
            }

            agregarNuevoEstudiante() {
                const clone = templateEstudiante.cloneNode(true);

                clone.querySelector("h5 .text-primary").textContent = this.nombre;
                clone.querySelector("h6").textContent = this.getEstudiante;
                clone.querySelector(".lead").textContent = this.edad;

                if (this.#estado) {
                    clone.querySelector(".badge").className = "badge bg-success";
                    clone.querySelector(".btn-success").disabled = true;
                    clone.querySelector(".btn-danger").disabled = false;
                } else {
                    clone.querySelector(".badge").className = "badge bg-danger";
                    clone.querySelector(".btn-danger").disabled = true;
                    clone.querySelector(".btn-success").disabled = false;
                }
                clone.querySelector(".badge").textContent = this.#estado
                    ? "Aprobado"
                    : "Reprobado";

                // reemplaze por uid
                clone.querySelector(".btn-success").dataset.uid = this.uid;
                clone.querySelector(".btn-danger").dataset.uid = this.uid;

                return clone;
            }
        }

        class Profesor extends Persona {
            #profesor = "Profesor";

            agregarNuevoProfesor() {
                const clone = templateProfesor.cloneNode(true);
                clone.querySelector("h5").textContent = this.nombre;
                clone.querySelector("h6").textContent = this.#profesor;
                clone.querySelector(".lead").textContent = this.edad;
                return clone;
            }
        }

        formulario.addEventListener("submit", (e) => {
            e.preventDefault();
            alert.classList.add("d-none");

            const datos = new FormData(formulario);

            const [nombre, edad, opcion] = [...datos.values()];

            // validaci√≥n de campos vac√≠os
            if (!nombre.trim() || !edad.trim() || !opcion.trim()) {
                console.log("Elemento vac√≠o");
                alert.classList.remove("d-none");
                return;
            }

            if (opcion === "Estudiante") {
                const estudiante = new Estudiante(nombre, edad);
                estudiantes.push(estudiante);
                Persona.pintarPersonaUI(estudiantes, opcion);
            }

            if (opcion === "Profesor") {
                const profesor = new Profesor(nombre, edad);
                profesores.push(profesor);
                Persona.pintarPersonaUI(profesores, opcion);
            }
        });




    </body>
    </html>